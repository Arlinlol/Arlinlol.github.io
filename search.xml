<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Dart是个啥，一文了解！</title>
    <url>/31296/</url>
    <content><![CDATA[<h3 id="前言"><a class="header-anchor" href="#前言">¶</a> 前言</h3>
<p>Flutter这两年火了，最近有个自己的项目在筹备中，决定用Flutter实现，Flutter应用程序使用Dart语言开发，Dart是面向对象编程语言，由Google于2011年推出，目前最新版本是2.0，为了更好的使用Flutter进行应用开发，本文将详细介绍Dart语言的语法和特性。</p>
<h3 id="重要概念"><a class="header-anchor" href="#重要概念">¶</a> 重要概念</h3>
<p>在学习Dart之前要了解一下Dart相关概念：</p>
<ol>
<li>能够放在变量中的所有内容都是对象，每一个对象都是一个类的实例。甚至于数字、函数和null值都是丢向，并且所有对象都继承自Object类。</li>
<li>Dart是强类型语言，但类型标识是可选的，因为Dart可以推断类型。如果要明确说明不需要任何类型，可以使用类型<code>dynamic</code>标识。</li>
<li>Dart支持反省，如List或者任何类型的对象列表。</li>
<li>Dart支持顶级函数（例如main函数），以及绑定到类或者对象的函数（分别是静态方法和实例方法）。函数内部可以创建函数（嵌套函数或者本地函数）。</li>
<li>Dart支持顶级变量，以及绑定到类或对象的变量（分别是静态变量和实例变量）。</li>
<li>与Java不通，Dart没有关键字<code>public</code>、<code>protected</code>和<code>private</code>。如果设置私有变量或者函数，则变量和函数名以下划线<code>——</code>开头。</li>
<li>标识符可以以字母或者下划线<code>_</code>开头，后跟这些字符加数字的任意组合。</li>
<li>Dart有两个表达式（具有运行时值）和语句(不具有)。例如三元表达式<code>?expr1:expr2</code>的值为expr1或expr2。将其余if-else语句进行比较，该语句没有任何职。语句通畅包含一个或多个表达式，但表达式不能直接包含语句。</li>
<li>Dart工具可以报告两种问题：告警和错误。告警知识表明您的代码可能无法正常工作，但他不会阻止你的程序执行。错误可以是编译时或者运行时。编译时错误会组织代码执行；运行时错误导致代码执行时发生异常。</li>
</ol>
<h3 id="关键字"><a class="header-anchor" href="#关键字">¶</a> 关键字</h3>
<p>任何语言都有关键字，关键字是在编程时不能使用作为标识符的单次。Dart的关键字如下：<br>
<img src="/images/pasted-2.png" alt="upload successful"></p>
<p>编码时应避免使用以上单词作为标识符，如果有必要，可以使用带有上标的单词作为标识符：</p>
<ul>
<li>带有上标1的单词是上下文关键字，仅在特定位置有含义，它们在任何地方都是有效的；</li>
<li>带有上标2的单词是内置标识符，它们在大多数地方是有效的，但不能用作为类和类型名称或作为一个导入前缀；</li>
<li>带有上标3的单词是与Dart1.0发布后添加的异步支持相关的有限的保留字符，不能在任何标记为async，async * 或sync * 的任何函数体中使用await和yield作为标识符</li>
</ul>
<h3 id="变量"><a class="header-anchor" href="#变量">¶</a> 变量</h3>
<h4 id="变量的定义"><a class="header-anchor" href="#变量的定义">¶</a> 变量的定义</h4>
<ol>
<li>可以使用var来定义变量，变量的类型可以通过变量值来推断出来</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name &#x3D; &quot;hi&quot;; &#x2F;&#x2F;String类型</span><br><span class="line">var age &#x3D; 18; &#x2F;&#x2F;int类型</span><br><span class="line">var high &#x3D; 1.70; &#x2F;&#x2F;double类型</span><br></pre></td></tr></table></figure>
<p>如上变量定义后其类型已经确定，不可再将其他类型的值赋给变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name &#x3D; &quot;hi&quot;; &#x2F;&#x2F;String类型</span><br><span class="line">name &#x3D; 3; &#x2F;&#x2F;此处编译器会报错，name被定义赋值之后已经是一个String类型，不可再赋值int类型值</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>也可以使用特定类型来定义变量</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String name &#x3D; &quot;bruce&quot;; &#x2F;&#x2F;String类型</span><br><span class="line">int age &#x3D; 18; &#x2F;&#x2F;int类型</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>如果变量不限于单个类型，则可以使用dynamic或Object来定义变量</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dynamic value &#x3D; 18;</span><br><span class="line">print(&quot;value &#x3D; $value&quot;);</span><br><span class="line">value &#x3D; &quot;bruce&quot;;</span><br><span class="line">print(&quot;value &#x3D; $value&quot;);</span><br><span class="line">value &#x3D; 3.5;</span><br><span class="line">print(&quot;value &#x3D; $value&quot;);</span><br><span class="line">  </span><br><span class="line">Object val &#x3D; 18;</span><br><span class="line">print(&quot;val &#x3D; $val&quot;);</span><br><span class="line">val &#x3D; &quot;bruce&quot;;</span><br><span class="line">print(&quot;val &#x3D; $val&quot;);</span><br><span class="line">val &#x3D; 3.5;</span><br><span class="line">print(&quot;val &#x3D; $val&quot;);</span><br></pre></td></tr></table></figure>
<p>输出结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">value &#x3D; 18</span><br><span class="line">value &#x3D; bruce</span><br><span class="line">value &#x3D; 3.5</span><br><span class="line">val &#x3D; 18</span><br><span class="line">val &#x3D; bruce</span><br><span class="line">val &#x3D; 3.5</span><br></pre></td></tr></table></figure>
<h4 id="变量的默认值"><a class="header-anchor" href="#变量的默认值">¶</a> 变量的默认值</h4>
<p>由于前文关于Dart的一些概念中说到过，能够放在变量中的所有内容都是对象，所以如果一个变量没有初始化值，那它的默认值就为null。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int value1;</span><br><span class="line">print(&quot;value1 &#x3D; $value1&quot;);</span><br><span class="line">bool value2;</span><br><span class="line">print(&quot;value2 &#x3D; $value2&quot;);</span><br><span class="line">var value3;</span><br><span class="line">print(&quot;value3 &#x3D; $value3&quot;);</span><br><span class="line">dynamic value4;</span><br><span class="line">print(&quot;value4 &#x3D; $value4&quot;);</span><br></pre></td></tr></table></figure>
<p>输出结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">value1 &#x3D; null</span><br><span class="line">value2 &#x3D; null</span><br><span class="line">value3 &#x3D; null</span><br><span class="line">value4 &#x3D; null</span><br></pre></td></tr></table></figure>
<h4 id="final 和 const"><a class="header-anchor" href="#final 和 const">¶</a> final 和 const</h4>
<p>如果不打算更改变量，可以使用final或者const。一个final变量只能被设置一次，而const变量是编译时常量，定义时必须赋值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Person类</span><br><span class="line">class Person &#123;</span><br><span class="line">  static const desc &#x3D; &quot;This is a Person class&quot;; &#x2F;&#x2F;必须定义时赋值，否则编译时报错</span><br><span class="line">  final name;</span><br><span class="line">  Person(this.name); &#x2F;&#x2F;对象初始化时赋值一次</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义一个Person对象</span><br><span class="line">Person p &#x3D; Person(&quot;Bruce&quot;); &#x2F;&#x2F;构造函数，创建对象时设置一次name</span><br><span class="line">print(&quot;p.name &#x3D; $&#123;p.name&#125;&quot;); &#x2F;&#x2F;可正常输出 p.name &#x3D; Bruce</span><br><span class="line">p.name &#x3D; &quot;haha&quot;; &#x2F;&#x2F;编译器报错</span><br></pre></td></tr></table></figure>
<h3 id="内置类型"><a class="header-anchor" href="#内置类型">¶</a> 内置类型</h3>
<p>Dart语言支持以下类型：</p>
<ul>
<li>numbers<br>
包含int和double两种类型，没有像Java中的float类型，int和double都是num的子类型。</li>
<li>strings<br>
Dart的字符串是一系列UTF-16代码单元。创建方法如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String str1 &#x3D; &quot;hello&quot;; &#x2F;&#x2F;可以使用单引号或双引号</span><br><span class="line">print(&quot;str1 &#x3D; $str1&quot;);</span><br><span class="line">String str2 &#x3D; &quot;&quot;&quot;Hi,Bruce</span><br><span class="line">This is Xiaoming.</span><br><span class="line">&quot;&quot;&quot;; &#x2F;&#x2F;使用带有单引号或双引号的三重引号可以创建多行字符串</span><br><span class="line">print(&quot;str2 &#x3D; $str2&quot;);</span><br></pre></td></tr></table></figure>
<p>输出结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str1 &#x3D; hello</span><br><span class="line">str2 &#x3D; Hi,Bruce</span><br><span class="line">  This is Xiaoming.</span><br></pre></td></tr></table></figure>
<ul>
<li>booleans<br>
Dart有一个名为bool的类型，只有两个对象具有bool类型：true和false，他们都是编译时常量。</li>
<li>lists<br>
和其他编程语言常见的集合一样，Dart中使用的集合是数组或有序的对象组。Dart中数组是List对象。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List arr &#x3D; [&quot;Bruce&quot;, &quot;Nick&quot;, &quot;John&quot;];</span><br><span class="line">print(&quot;arr &#x3D; $arr&quot;);</span><br></pre></td></tr></table></figure>
<ul>
<li>maps</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Map map &#x3D; &#123;</span><br><span class="line">&quot;name&quot;: &quot;Bruce&quot;,</span><br><span class="line">&quot;age&quot;: 18,</span><br><span class="line">&quot;high&quot;: 1.70</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">print(&quot;map &#x3D; $map&quot;);</span><br><span class="line">print(&quot;map[&#39;name&#39;] &#x3D; $&#123;map[&#39;name&#39;]&#125;&quot;);</span><br><span class="line"></span><br><span class="line">var map1 &#x3D; &#123;</span><br><span class="line">1: &quot;hi&quot;,</span><br><span class="line">2: &quot;hello&quot;,</span><br><span class="line">3: &quot;yep&quot;</span><br><span class="line">&#125;;</span><br><span class="line">print(&quot;map1 &#x3D; $map1&quot;);</span><br><span class="line">print(&quot;map1[1] &#x3D; $&#123;map1[1]&#125;&quot;);</span><br></pre></td></tr></table></figure>
<p>输出结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">map &#x3D; &#123;name: Bruce, age: 18, high: 1.7&#125;</span><br><span class="line">map[&#39;name&#39;] &#x3D; Bruce</span><br><span class="line">map1 &#x3D; &#123;1: hi, 2: hello, 3: yep&#125;</span><br><span class="line">map1[1] &#x3D; hi</span><br></pre></td></tr></table></figure>
<ul>
<li>runes<br>
符文是字符串的UTF-32代码点。在字符串中表示32位Unicode值需要特殊语法，常用方法是 \uXXXX，其中XXXX是4位十六进制值，比如小心心（♥）是\u2665。要指定多于或少于4个十六进制数字，请将值放在大括号中。 比如，微笑（😆）是\u{1f600}。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String smile &#x3D; &#39;\u&#123;1f600&#125;&#39;;</span><br><span class="line">print(&quot;微笑：$smile&quot;);</span><br><span class="line"></span><br><span class="line">Runes input &#x3D; new Runes(</span><br><span class="line">  &#39;\u2665  \u&#123;1f605&#125;  \u&#123;1f60e&#125;  \u&#123;1f47b&#125;  \u&#123;1f596&#125;  \u&#123;1f44d&#125;&#39;);</span><br><span class="line">print(String.fromCharCodes(input));</span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">微笑：😀</span><br><span class="line">♥  😅  😎  👻  🖖  👍</span><br></pre></td></tr></table></figure>
<h3 id="函数"><a class="header-anchor" href="#函数">¶</a> 函数</h3>
<p>Dart是一种真正的面向对象语言，因此即使是函数也是对象并且具有类型Function。这意味着函数可以分配给变量或作为参数传递给其他函数。</p>
<h4 id="定义方法"><a class="header-anchor" href="#定义方法">¶</a> 定义方法</h4>
<p>和绝大多数编程语言一样，Dart函数通常的定义方式为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String getName() &#123;</span><br><span class="line">  return &quot;Bruce&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果函数体中只包含一个表达式，则可以使用简写语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String getName() &#x3D;&gt; &quot;Bruce&quot;;</span><br></pre></td></tr></table></figure>
<h4 id="可选参数"><a class="header-anchor" href="#可选参数">¶</a> 可选参数</h4>
<p>Dart函数可以设置可选参数，可以使用命名参数也可以使用位置参数。</p>
<p>命名参数，定义格式如 <code>{param1, param2, …}</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 函数定义</span><br><span class="line">void showDesc(&#123;var name, var age&#125;) &#123;</span><br><span class="line">  if(name !&#x3D; null) &#123;</span><br><span class="line">    print(&quot;name &#x3D; $name&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  if(age !&#x3D; null) &#123;</span><br><span class="line">    print(&quot;age &#x3D; $age&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 函数调用</span><br><span class="line">showDesc(name: &quot;Bruce&quot;);</span><br><span class="line">&#x2F;&#x2F; 输出结果</span><br><span class="line">name &#x3D; Bruce</span><br></pre></td></tr></table></figure>
<p>位置参数，使用 [] 来标记可选参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 函数定义</span><br><span class="line">void showDesc(var name, [var age]) &#123;</span><br><span class="line">  print(&quot;name &#x3D; $name&quot;);</span><br><span class="line">  </span><br><span class="line">  if(age !&#x3D; null) &#123;</span><br><span class="line">    print(&quot;age &#x3D; $age&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 函数调用</span><br><span class="line">showDesc(&quot;Bruce&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出结果</span><br><span class="line">name &#x3D; Bruce</span><br></pre></td></tr></table></figure>
<h4 id="默认值"><a class="header-anchor" href="#默认值">¶</a> 默认值</h4>
<p>函数的可选参数也可以使用 = 设置默认值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 函数定义</span><br><span class="line">void showDesc(var name, [var age &#x3D; 18]) &#123;</span><br><span class="line">  print(&quot;name &#x3D; $name&quot;);</span><br><span class="line">  </span><br><span class="line">  if(age !&#x3D; null) &#123;</span><br><span class="line">    print(&quot;age &#x3D; $age&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 函数调用</span><br><span class="line">showDesc(&quot;Bruce&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出结果</span><br><span class="line">name &#x3D; Bruce</span><br><span class="line">age &#x3D; 18</span><br></pre></td></tr></table></figure>
<h4 id="mian函数"><a class="header-anchor" href="#mian函数">¶</a> mian函数</h4>
<p>和其他编程语言一样，Dart中每个应用程序都必须有一个顶级main()函数，该函数作为应用程序的入口点。</p>
<h4 id="函数作为参数"><a class="header-anchor" href="#函数作为参数">¶</a> 函数作为参数</h4>
<p>Dart中的函数可以作为另一个函数的参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 函数定义</span><br><span class="line">void println(String name) &#123;</span><br><span class="line">  print(&quot;name &#x3D; $name \n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void showDesc(var name, Function log) &#123;</span><br><span class="line">  log(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 函数调用</span><br><span class="line">showDesc(&quot;Bruce&quot;, println);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出结果</span><br><span class="line">name &#x3D; Bruce</span><br></pre></td></tr></table></figure>
<h4 id="匿名函数"><a class="header-anchor" href="#匿名函数">¶</a> 匿名函数</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 函数定义</span><br><span class="line">void showDesc(var name, Function log) &#123;</span><br><span class="line">  log(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 函数调用，匿名函数作为参数</span><br><span class="line">showDesc(&quot;Bruce&quot;, (name) &#123;</span><br><span class="line">    print(&quot;name &#x3D; $name&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出结果</span><br><span class="line">name &#x3D; Bruce</span><br></pre></td></tr></table></figure>
<h4 id="嵌套函数"><a class="header-anchor" href="#嵌套函数">¶</a> 嵌套函数</h4>
<p>Dart支持嵌套函数，也就是函数中可以定义函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 函数定义</span><br><span class="line">void showDesc(var name) &#123;</span><br><span class="line">  print(&quot;That is a nested function!&quot;);</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;函数中定义函数</span><br><span class="line">  void println(var name) &#123;</span><br><span class="line">    print(&quot;name &#x3D; $name&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  println(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 函数调用</span><br><span class="line">showDesc(&quot;Bruce&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出结果</span><br><span class="line">That is a nested function!</span><br><span class="line">name &#x3D; Bruce</span><br></pre></td></tr></table></figure>
<h3 id="运算符"><a class="header-anchor" href="#运算符">¶</a> 运算符</h3>
<p><img src="/images/pasted-3.png" alt="upload successful"></p>
<p>下面就对一些对于Java或Objective-C来说未使用过的运算符通过代码来做个介绍。</p>
<ul>
<li><code>?.</code>使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;定义类</span><br><span class="line">class Person &#123;</span><br><span class="line">  var name;</span><br><span class="line">  Person(this.name);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 调用</span><br><span class="line">Person p;</span><br><span class="line">var name &#x3D; p?.name; &#x2F;&#x2F;先判断p是否为null，如果是，则name为null；如果否，则返回p.name值</span><br><span class="line">print(&quot;name &#x3D; $name&quot;);</span><br><span class="line">&#x2F;&#x2F; 输出结果</span><br><span class="line">name &#x3D; null</span><br></pre></td></tr></table></figure>
<ul>
<li><code>~/</code>的使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 代码语句</span><br><span class="line">var num &#x3D; 10;</span><br><span class="line">var result &#x3D; num ~&#x2F; 3; &#x2F;&#x2F;得出一个小于等于(num&#x2F;3)的最大整数</span><br><span class="line">print(&quot;result &#x3D; $result&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出结果</span><br><span class="line">result &#x3D; 3</span><br></pre></td></tr></table></figure>
<ul>
<li><code>as</code>的使用，as用来类型转化</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 类定义</span><br><span class="line">class Banana &#123;</span><br><span class="line">  var weight;</span><br><span class="line">  Banana(this.weight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Apple &#123;</span><br><span class="line">  var weight;</span><br><span class="line">  Apple(this.weight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 调用</span><br><span class="line">dynamic b &#x3D; Banana(20);</span><br><span class="line">(b as Banana).weight &#x3D; 20; &#x2F;&#x2F; 正常执行</span><br><span class="line">print(&quot;b.weight &#x3D; $&#123;(b as Banana).weight&#125;&quot;);</span><br><span class="line">(b as Apple).weight &#x3D; 30; &#x2F;&#x2F; 类型转换错误，运行报错</span><br><span class="line">print(&quot;b.weight &#x3D; $&#123;(b as   Apple).weight&#125;&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出结果</span><br><span class="line">b.weight &#x3D; 20</span><br><span class="line">Uncaught exception:</span><br><span class="line">CastError: Instance of &#39;Banana&#39;: type &#39;Banana&#39; is not a subtype of type &#39;Apple&#39;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>is</code>的使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 函数和类代码定义</span><br><span class="line">getFruit() &#x3D;&gt; Banana(20); &#x2F;&#x2F; 获取一个水果对象</span><br><span class="line"></span><br><span class="line">class Banana &#123;</span><br><span class="line">  var weight;</span><br><span class="line">  Banana(this.weight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Apple &#123;</span><br><span class="line">  var color;</span><br><span class="line">  Apple(this.color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 调用</span><br><span class="line">var b &#x3D; getFruit();</span><br><span class="line">if(b is Apple) &#123; &#x2F;&#x2F;判断对象是否为Apple类</span><br><span class="line">  print(&quot;The fruit is an apple&quot;);</span><br><span class="line">&#125; else if(b is Banana) &#123; &#x2F;&#x2F;判断水果是否为Banana类</span><br><span class="line">  print(&quot;The fruit is a banana&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出结果</span><br><span class="line">The fruit is a banana</span><br></pre></td></tr></table></figure>
<ul>
<li><code>??</code>的使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 操作代码块</span><br><span class="line">String name;</span><br><span class="line">String nickName &#x3D; name ?? &quot;Nick&quot;; &#x2F;&#x2F;如果name不为null，则nickName值为name的值，否则值为Nick</span><br><span class="line">print(&quot;nickName &#x3D; $nickName&quot;);</span><br><span class="line">  </span><br><span class="line">name &#x3D; &quot;Bruce&quot;;</span><br><span class="line">nickName &#x3D; name ?? &quot;Nick&quot;; &#x2F;&#x2F;如果name不为null，则nickName值为name的值，否则值为Nick</span><br><span class="line">print(&quot;nickName &#x3D; $nickName&quot;);</span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F; 输出结果</span><br><span class="line">nickName &#x3D; Nick</span><br><span class="line">nickName &#x3D; Bruce</span><br></pre></td></tr></table></figure>
<ul>
<li><code>..</code>的使用，级联操作允许同一个</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 类定义</span><br><span class="line">class Banana &#123;</span><br><span class="line">  var weight;</span><br><span class="line">  var color;</span><br><span class="line">  Banana(this.weight, this.color);</span><br><span class="line">  </span><br><span class="line">  void showWeight() &#123;</span><br><span class="line">    print(&quot;weight &#x3D; $weight&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  void showColor() &#123;</span><br><span class="line">    print(&quot;color &#x3D; $color&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 调用</span><br><span class="line">Banana(20, &#39;yellow&#39;)</span><br><span class="line">    ..showWeight()</span><br><span class="line">    ..showColor();</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; 输出结果</span><br><span class="line">weight &#x3D; 20</span><br><span class="line">color &#x3D; yellow</span><br></pre></td></tr></table></figure>
<h3 id="控制流语句"><a class="header-anchor" href="#控制流语句">¶</a> 控制流语句</h3>
<p>Dart中的控制流语句和其他语言一样，包含以下方式</p>
<ul>
<li>if and else</li>
<li>for循环</li>
<li>while和do-while循环</li>
<li>break和continue</li>
<li>switch-case语句<br>
以上控制流语句和其他编程语言用法一样，switch-case有一个特殊的用法如下，可以使用continue语句和标签来执行指定case语句。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fruit &#x3D; &#39;apple&#39;;</span><br><span class="line">switch (fruit) &#123;</span><br><span class="line">  case &#39;banana&#39;:</span><br><span class="line">    print(&quot;this is a banana&quot;);</span><br><span class="line">    continue anotherFruit;</span><br><span class="line">      </span><br><span class="line">  anotherFruit:</span><br><span class="line">  case &#39;apple&#39;:</span><br><span class="line">    print(&quot;this is an apple&quot;);</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出结果</span><br><span class="line">this is an apple</span><br></pre></td></tr></table></figure>
<h3 id="异常"><a class="header-anchor" href="#异常">¶</a> 异常</h3>
<p>Dart的异常捕获也是使用try-catch语法，不过与java等语言稍有不同</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义一个抛出异常的函数</span><br><span class="line">void handleOperator() &#x3D;&gt; throw Exception(&quot;this operator exception!&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 函数调用</span><br><span class="line">try &#123;</span><br><span class="line">  handleOperator();</span><br><span class="line">&#125; on Exception catch(e) &#123;</span><br><span class="line">  print(e);</span><br><span class="line">&#125; finally &#123; &#x2F;&#x2F; finally语句可选</span><br><span class="line">  print(&quot;finally&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出结果</span><br><span class="line">Exception: this operator exception!</span><br><span class="line">finally</span><br></pre></td></tr></table></figure>
<h3 id="类"><a class="header-anchor" href="#类">¶</a> 类</h3>
<p>Dart是一种面向对象的语言，具有类和基于mixin的继承。同Java一样，Dart的所有类也都继承自Object。</p>
<h4 id="构造函数"><a class="header-anchor" href="#构造函数">¶</a> 构造函数</h4>
<p>Dart的构造函数同普通函数一样，可以定义无参和有参，命名参数和位置参数，可选参数和给可选参数设置默认值等。Dart的构造函数有以下几个特点：</p>
<ul>
<li>可以定义命名构造函数</li>
<li>可以在函数体运行之前初始化实例变量</li>
<li>子类不从父类继承构造函数，定义没有构造函数的子类只有无参无名称的构造函数</li>
<li>子类定义构造函数时默认继承父类无参构造函数，也可继承指定有参数的构造函数；</li>
</ul>
<p>命名构造函数和函数体运行前初始化实例变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 类定义</span><br><span class="line">class Tree &#123;</span><br><span class="line">  var desc;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 命名构造函数</span><br><span class="line">  Tree.init() &#123;</span><br><span class="line">    desc &#x3D; &quot;this is a seed&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 函数体运行之前初始化实例变量</span><br><span class="line">  Tree(var des) : desc &#x3D; des;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 构造函数调用</span><br><span class="line">Tree t &#x3D; Tree.init();</span><br><span class="line">print(&quot;$&#123;t.desc&#125;&quot;);</span><br><span class="line"></span><br><span class="line">Tree t1 &#x3D; Tree(&quot;this is a tree&quot;);</span><br><span class="line">print(&quot;$&#123;t1.desc&#125;&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出结果</span><br><span class="line">this is a seed</span><br><span class="line">this is a tree</span><br></pre></td></tr></table></figure>
<p>构造函数继承</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 类定义</span><br><span class="line">class Fruit &#123;</span><br><span class="line">  Fruit() &#123;</span><br><span class="line">    print(&quot;this is Fruit constructor with no param&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  Fruit.desc(var desc) &#123;</span><br><span class="line">    print(&quot;$desc in Fruit&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Apple extends Fruit &#123;</span><br><span class="line">  Apple():super() &#123;</span><br><span class="line">    print(&quot;this is Apple constructor with no param&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 默认继承无参构造函数</span><br><span class="line">  Apple.desc(var desc) &#123;</span><br><span class="line">    print(&#39;$desc in Apple&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 构造函数调用</span><br><span class="line">Apple();</span><br><span class="line">Apple.desc(&quot;say hello&quot;);</span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F; 输出结果</span><br><span class="line">this is Fruit constructor with no param</span><br><span class="line">this is Apple constructor with no param</span><br><span class="line">this is Fruit constructor with no param</span><br><span class="line">say hello in Apple</span><br></pre></td></tr></table></figure>
<h4 id="mixin继承"><a class="header-anchor" href="#mixin继承">¶</a> mixin继承</h4>
<p>mixin是一种在多个类层次结构中重用类代码的方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 类定义</span><br><span class="line">class LogUtil &#123;</span><br><span class="line">  void log() &#123;</span><br><span class="line">    print(&quot;this is a log&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Fruit &#123;</span><br><span class="line">  Fruit() &#123;</span><br><span class="line">    print(&quot;this is Fruit constructor with no param&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Apple extends Fruit with LogUtil &#123;</span><br><span class="line">  Apple():super() &#123;</span><br><span class="line">    print(&quot;this is Apple constructor with no param&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 调用</span><br><span class="line">Apple a &#x3D; Apple();</span><br><span class="line">a.log(); &#x2F;&#x2F;可执行从LogUtil继承过来的方法</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出结果</span><br><span class="line">this is Fruit constructor with no param</span><br><span class="line">this is Apple constructor with no param</span><br><span class="line">this is a log</span><br></pre></td></tr></table></figure>
<h3 id="泛型"><a class="header-anchor" href="#泛型">¶</a> 泛型</h3>
<p>Dart和java一样，支持泛型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 类定义</span><br><span class="line">class Apple &#123;</span><br><span class="line">  var desc;</span><br><span class="line">  Apple(this.desc);</span><br><span class="line">  </span><br><span class="line">  void log() &#123;</span><br><span class="line">    print(&quot;$&#123;this.desc&#125;&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Banana &#123;</span><br><span class="line">  var desc;</span><br><span class="line">  Banana(this.desc);</span><br><span class="line">  </span><br><span class="line">  void log() &#123;</span><br><span class="line">    print(&quot;$&#123;this.desc&#125;&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class FruitFactory&lt;T&gt; &#123;</span><br><span class="line">  T produceFruit(T t) &#123;</span><br><span class="line">    return t;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 调用</span><br><span class="line">FruitFactory&lt;Banana&gt; f &#x3D; FruitFactory&lt;Banana&gt;();</span><br><span class="line">Banana b &#x3D; f.produceFruit(Banana(&quot;a banana&quot;));</span><br><span class="line">b.log();</span><br><span class="line">  </span><br><span class="line">FruitFactory&lt;Apple&gt; f1 &#x3D; FruitFactory&lt;Apple&gt;();</span><br><span class="line">Apple a &#x3D; f1.produceFruit(Apple(&quot;an apple&quot;));</span><br><span class="line">a.log();</span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F; 输出结果</span><br><span class="line">a banana</span><br><span class="line">an apple</span><br></pre></td></tr></table></figure>
<h3 id="写在最后"><a class="header-anchor" href="#写在最后">¶</a> 写在最后</h3>
<p>本文主要针对Dart不同于其他编程语言的一些语法特性进行了分析和举例，相信读过文本之后大家会对Dart语法有个很系统的了解，后边我们就可以开启Flutter应用开发之旅了。</p>
<p><a href="https://mp.weixin.qq.com/s/lEUdry-pl40GuHPSYtPYpg" target="_blank" rel="noopener">本文转载自微信公众号:Flutter编程智能</a> ，这篇文章对我迅速了解Dart语言有很大的帮助，值得推荐！</p>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css">]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title>The garden 16</title>
    <url>/30102/</url>
    <content><![CDATA[<blockquote>
<p>Ranbindranath Tagore</p>
</blockquote>
<p>Hands cling to hands and eyes linger eyes;</p>
<p>thus begins the record of our hearts.</p>
<p>it’s the moonlit night of March ;</p>
<p>the sweet smile of henna is in the air;</p>
<p>my flute lies on the earth neglected<br>
and your garland of flowers is unfinished ,</p>
<p>This love between you and me is simple as a song .</p>
<p>your veil of the saffron colour makes my eyes drunk .</p>
<p>the jasmine wreath that you wove me thrill to my hearts like praise .</p>
<p>it’s a game of giving and withoutholding ,revealing and screening again ;</p>
<p>some smile and some little shyness,</p>
<p>and some sweet useless struggles,</p>
<p>this love between you and me is simple as a song .</p>
<p>no mystery beyond the present ;</p>
<p>no striving for the impossible ;</p>
<p>no shadownbehind the charm ;</p>
<p>no groping in the depth of the dark ,</p>
<p>this love between you and me is simple as a song .</p>
<p>we don’t raise our hands to the void for things beyond hope.</p>
<p>it’s enough what we give and we get</p>
<p>we have not crushed the joy to the utmost to wring from it the wine of pain .</p>
<p>this love between you and me is simple as a song .</p>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css">]]></content>
      <tags>
        <tag>诗歌</tag>
      </tags>
  </entry>
  <entry>
    <title>VUE是个啥？</title>
    <url>/40535/</url>
    <content><![CDATA[<h2 id="为什么要讨论VUE"><a class="header-anchor" href="#为什么要讨论VUE">¶</a> 为什么要讨论VUE</h2>
<p>首先我之前并不是搞前端的，十几年前开始接触编程，从C到C++、Delphi、C#、Java到WEB开发的HTML、JavaScript、少量CSS，JSP、JAVA等框架，数据库等等。那时候除了计算机基础知识外，判断一个软件开发工程师是游击队还是正规军的标准还是是不是科班出身，学没学过算法、数据结构、图论等等。面试的时候问的问题大部分都是算法和编程语言相关的。当C#、Java、PHP出现一段时间后，随着互联网的发展WEB开发崛起，给国内第一代程序员带来了巨大的压力，当时他们感觉编程未来是愚钝化、便捷化、拖拉拽就能解决的，开源会使编程代价更低，开源到一定时间，代码就会‘云化’集成在IDE工具里，各个功能拽一下就有了甚至会有业务逻辑的轻松实现（当时据说微软提出了一个概念，类似于把代码都存储在互联网上，让更多的业务人员学会使用IDE自行拖拉拽就完事了，没有程序员毛事。），看着手里的VC6.0或Delphi的IDE匆匆的合上了电脑有的下海了，有的干上了管理，极少数的创业了。</p>
<p>还有一个C/C++程序员曾经跟我说过他放弃软件开发工作的原因是到了一个尴尬的处境，硬件变得的不值钱，服务器都集群化，之前写的程序抠抠搜搜研究了几个星期尽量节省内存的事情显得没有那么大的意义。导致他放弃的原因我认为有几个：</p>
<ul>
<li>
<p>一是向底层或算法进展，玩到最后是数学，物理，宇宙。觉得脑子不够用，不行。</p>
</li>
<li>
<p>二是向业务层进展，和客户/业务人员终于磨合了半年明白对方的意图之后，新招聘的JAVA程序员乐呵的一个月整出来个大概，而看着自己手里擅长的C/C++感觉得整三五个月。</p>
</li>
<li>
<p>三是排斥新的东西，放弃了学习。</p>
</li>
<li>
<p>四是觉得干管理或者干业务干好了比软件开发工程师寿命长，这个属于职业规划上的，我相信当时他没想那么远。</p>
</li>
</ul>
<p>另外关于“前端工程师/中台工程师/后端工程师”，这都是随着软件工程的系统化针对互联网业务的发展衍生出来的职业岗位，也可以理解为是程序员们给自己多创造了几倍的就业岗位。<br>
说了这么多就是为了勉励一下自己，要不停的学习。VUE出来这么久，之前也在一些小项目上应用了一下，并没有深入的去系统性或者从实用性的角度去学习和记录。</p>
<h2 id="Vue是干什么的，用来解决什么问题？"><a class="header-anchor" href="#Vue是干什么的，用来解决什么问题？">¶</a> Vue是干什么的，用来解决什么问题？</h2>
<h4 id="官方的解释是："><a class="header-anchor" href="#官方的解释是：">¶</a> 官方的解释是：</h4>
<p>Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。<br>
如果你想在深入学习 Vue 之前对它有更多了解，我们制作了一个视频，带您了解其核心概念和一个示例工程。<br>
如果你已经是有经验的前端开发者，想知道 Vue 与其它库/框架有哪些区别，请查看对比其它框架。</p>
<blockquote>
<p>这里边吧，有好多名词“渐进式框架”“自底向上逐层应用”“视图层”“工具链”等等。不太容易理解，因为他们也找不到什么看起来更高大上的次了，总写PPT的人知道，title一定要响亮，贾跃亭最明白，生态系统、逆向生态，大数据等等。都是一些老的业务包装了一下，显得高大上了。所以这里暂时不用去费劲巴力的理解那些名词，还没等理解可能你就准备放弃了</p>
</blockquote>
<h4 id="Vue到底是什么？"><a class="header-anchor" href="#Vue到底是什么？">¶</a> Vue到底是什么？</h4>
<p>VUE是一个工具，基于JavaScript语言的。</p>
<p>VUE能够解决过去用JavaScript拼装HTML代码的典型问题。我想大多数人都写过类似的代码吧。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var trs &#x3D; &#39;&#39;;</span><br><span class="line">$(xxx).each(function(o,n)&#123;</span><br><span class="line">  trs+&#x3D;&#39;&lt;tr&gt;&lt;td&gt;&#39;+n+&#39;&lt;&#x2F;td&gt;&#39;;</span><br><span class="line">  trs+&#x3D;&#39;&lt;td&gt;&#39;+o.xxx+&#39;&lt;&#x2F;td&gt;&#39;;</span><br><span class="line">  trs+&#x3D;&#39;&lt;td&gt;&#39;+o.yyy+&#39;&lt;&#x2F;td&gt;&#39;;</span><br><span class="line">  trs+&#x3D;&#39;&lt;td&gt;&#39;+o.zzz+&#39;&lt;&#x2F;td&gt;&#39;;</span><br><span class="line">  trs+&#x3D;&#39;&lt;&#x2F;tr&gt;&#39;;</span><br><span class="line">&#125;);</span><br><span class="line">$(id).append(trs);</span><br></pre></td></tr></table></figure>
<p>这样的代码，每次写起来很方便，逻辑简单，但是就是维护起来太差劲。随着系统的工程化，这种动态拼装HTML的情况会越来越多。<br>
另外在工程化的时候尽量要做到前后端的分离，是因为这个活不是一个人干了，同时代码可读性会更好。</p>
<p>以前看别人写的JSP程序的时候会看到这种&lt;% balabala…%&gt;在页面上直接写java代码，这给我的感觉是崩溃的，读起来非常费劲，总想用JSTL重写了，尽量把数据在后端组织好。</p>
<p>在这里要区分，免得误人子弟，上述JSTL和balabala…的写法，用户浏览器端发出请求的时候是服务器渲染好HTML代码后给用户端浏览器的，这里需要消耗服务器额外的性能。而基于JavaScript的都是在用户端的浏览器上运行，消耗的是用户设备的性能。现在浏览器变得越来越强大，用户端的配置也越来越高，所以这种前后端的分离会大大减少服务器的开销。这在互联网行业显得尤为重要，而对我们这种传统的IT服务供应商来讲，其实区别不大。</p>
<p>再聊回VUE，之前用JQuery的时候感觉也是很方便的，Vue和jQuery有什么不同吗。</p>
<p>当然有JQuery是JS工具箱，现在我们把一个网页应用抽象一下，那么HTML中的DOM其实就是视图，一个网页就是通过DOM的组合与嵌套，形成了最基本的视图结构，再通过CSS的修饰，在基本的视图结构上“化妆”让他们看起来更加美观。最后涉及到数据交互部分，就需要用到JavaScript来接受用户的交互请求，并且通过事件机制来响应用户的交互操作，并且在事件的处理函数中进行各种数据的修改，比如说修改某个DOM中的innerHTML或者innerText部分。</p>
<p>这里把HTML中的DOM就可以与其他的部分独立开来划分出一个层次，这个层次就叫做视图层。</p>
<blockquote>
<p>*** Vue 的核心库只关注视图层 ***</p>
</blockquote>
<h4 id="为什么只关注视图层"><a class="header-anchor" href="#为什么只关注视图层">¶</a> 为什么只关注视图层</h4>
<p>因为现在项目的功能越来越多，页面不再是单一的条件列表，尤其是互联网项目，尽量小的篇幅要有尽量多的信息量，结构很庞大，数据和视图如果全部混杂在一起，像传统开发一样全部混合在HTML中，那么要对它们进行处理会十分的费劲，并且如果其中有几个结构之间存在藕断丝连的关系，那么会导致代码上出现更大的问题。</p>
<p>你是否还记得你当初写JQuery的时候，有<code>$('#xxx').parent().parent().parent()</code>这种代码呢？当你第一次写的时候，你觉得页面元素不多，不就是找这个元素的爸爸的爸爸的爸爸吗，我大不了在注释里面写清楚这个元素的爸爸的爸爸的爸爸不就好了。但是万一过几天之后你的项目组长或者你的产品经理突然对你做的网页提出修改要求，这个修改要求将会影响页面的结构，也就是DOM的关联与嵌套层次要发生改变，那么<code>$('#xxx').parent().parent().parent()</code>可能就会变成<br>
<code>$('#xxx').parent().parent().parent().parent().parent()</code>了。</p>
<p>这还不算什么，等以后产品迭代越来越快，修改越来越多，而且页面中类似的关联和嵌套DOM元素不止一个，那么修改起来将非常费劲。而且JQuery选择器查找页面元素以及DOM操作本身也是有性能损失的，可能到时候打开这个页面，会变得越来越卡，而你却无从下手。</p>
<p>当你在编写项目的时候遇到了这种问题，你一定会抱怨，为什么世上会有HTML这种像盗梦空间一样的需要无数div嵌套才能做出页面的语言，为什么当初学JQuery看中的是它简洁的DOM操作，现在却一点也不觉得它有多简洁，难道我学的是假的JQuery？为什么写个代码这么难，你想砸电脑，你想一键盘拍在产品狗的脑袋上，责怪他天天改需求才让你原本花清香茶清味的代码变得如此又臭又长。</p>
<blockquote>
<p>*** Vue的初衷就是要解决这种问题的 ***</p>
</blockquote>
<h4 id="Vue为什么能让前端视图层开发起来这么方便？"><a class="header-anchor" href="#Vue为什么能让前端视图层开发起来这么方便？">¶</a> Vue为什么能让前端视图层开发起来这么方便？</h4>
<p>因为Vue.js有声明式，响应式的数据绑定，与组件化的开发，并且还使用了Virtual DOM这个看名字就觉得高大上的技术。</p>
<h5 id="数据绑定"><a class="header-anchor" href="#数据绑定">¶</a> 数据绑定</h5>
<p>就是数据绑也可以称为赋值，双向赋值，所谓双向的就是有变化自动更新，就像刚才我们实现表格一样，当表格里td的内容变化了，我们需要重新去执行一遍那个each方法，而vue就不用，JS里变量值变了，页面上那个值就跟着变了。不用你去干什么。是不是省事了。</p>
<p>就像整了一个监听器，一直监听那个变量有没有变化，有变化了就把所有用到这个变量的地方都重新执行以下。同样反过来也是，当页面有值变化了，不用去取value，自动的js里对应的这个变量也跟着变化。这就是双向绑定。</p>
<h5 id="组件化开发"><a class="header-anchor" href="#组件化开发">¶</a> 组件化开发</h5>
<p>还记得在传统前端开发的时候，我们都是每个人做一个页面，然后最后套入各种后端模版引擎，比如说C#的.NET或者Java的JSP等等。</p>
<p>但是现在我们做单页应用，页面交互和结构十分复杂，一个页面上就有许许多多的模块需要编写，而且往往一个模块的代码量和工作量就非常庞大，如果还按照原先的方法来开发，那么会累死人。而且遇到以后的产品需求变更，修改起来也非常麻烦，生怕动了其中一个div之后，其他div跟着雪崩，整个页面全部乱套，或者由于JavaScript的事件冒泡机制，导致修改一些内层的DOM事件处理函数之后，出现各种莫名其妙的诡异BUG。</p>
<p>在面向对象编程中，我们可以使用面向对象的思想将各种模块打包成类或者把一个大的业务模块拆分成更多更小的几个类。在面向过程编程中，我们也可以把一些大功能拆分成许多函数，然后分配给不同的人来开发。</p>
<p>在前端应用，我们是否也可以像编程一样把模块封装呢？这就引入了组件化开发的思想。</p>
<p>Vue通过组件，把一个单页应用中的各种模块拆分到一个一个单独的组件（component）中，我们只要先在父级应用中写好各种组件标签（占坑），并且在组件标签中写好要传入组件的参数（就像给函数传入参数一样，这个参数叫做组件的属性），然后再分别写好各种组件的实现（填坑），然后整个应用就算做完了。</p>
<h5 id="Virtual DOM"><a class="header-anchor" href="#Virtual DOM">¶</a> Virtual DOM</h5>
<p>现在的网速越来越快了，很多人家里都是几十甚至上百M的光纤，手机也是4G起步了，按道理一个网页才几百K，而且浏览器本身还会缓存很多资源文件，那么几十M的光纤为什么打开一个之前已经打开过，已经有缓存的页面还是感觉很慢呢？这就是因为浏览器本身处理DOM也是有性能瓶颈的，尤其是在传统开发中，用JQuery或者原生的JavaScript<br>
DOM操作函数对DOM进行频繁操作的时候，浏览器要不停的渲染新的DOM树，导致页面看起来非常卡顿。</p>
<p>而Virtual<br>
DOM则是虚拟DOM的英文，简单来说，他就是一种可以预先通过JavaScript进行各种计算，把最终的DOM操作计算出来并优化，由于这个DOM操作属于预处理操作，并没有真实的操作DOM，所以叫做虚拟DOM。最后在计算完毕才真正将DOM操作提交，将DOM操作变化反映到DOM树上。</p>
<p>对于vue.js的Virtual DOM，目前业界有着褒贬不一的评价。有人认为Vue.js作为一个轻量级框架，引入Virtual<br>
DOM会加大Vue.js本身的代码尺寸，也会消耗更多CPU（手机上会更耗电）（注意：消耗更多的CPU并不意味着会更卡，因为JavaScript计算是后台计算，他的计算量还不至于让DOM操作变得卡顿），并且在操作单个DOM元素的时候，反而多了一道计算工序，会更慢。但也有人认为基本上会用Vue.js开发的都是页面中内容很多的元素，肯定操作的DOM量级普遍较大，平均一下还是比较划算的。</p>
<h4 id="我到底该怎么用Vue.js做单页应用开发？"><a class="header-anchor" href="#我到底该怎么用Vue.js做单页应用开发？">¶</a> 我到底该怎么用Vue.js做单页应用开发？</h4>
<p>说了这么多，我还是不知道怎么用它做出一个像知乎那样的页面啊，到底怎么学它呢？</p>
<p>前面我们看了一个响应式的数据绑定案例，那只是一个DEMO，而且也看不出有什么实际意义，离真正的单页应用程序还差得远，到底怎么用它开发真实的项目呢？</p>
<p>我的建议是，先把介绍 - vue.js官方文档的基础部分硬着头皮看一遍。除了组件这个小节涉及到了很多晦涩难懂的名词以外，前面几章完全就是把Vue.js当作一个模版引擎来用。</p>
<p>然后开始学习ECMAScript6，Webpack，NPM以及Vue-Cli的基本用法，最好对Node.js也要有所了解。</p>
<p>最后组件部分先大致看一遍，了解组件里面都有哪些概念之后，开始看网上各种实战视频以及文章还有别人开源的源代码。<br>
在前面你提到过好几次ECMAScript，这是啥？</p>
<h4 id="在前面你提到过好几次ECMAScript，这是啥？"><a class="header-anchor" href="#在前面你提到过好几次ECMAScript，这是啥？">¶</a> 在前面你提到过好几次ECMAScript，这是啥？</h4>
<p>ECMAScript听名字好像和JavaScript很像，难不成他们有什么千丝万缕的联系？</p>
<p>引用阮一峰老师的教程：<a href="https://es6.ruanyifeng.com/#docs/intro" target="_blank" rel="noopener">ECMAScript 6入门</a></p>
<p>要讲清楚这个问题，需要回顾历史。1996年11月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript<br>
提交给国际标准化组织ECMA，希望这种语言能够成为国际标准。次年，ECMA<br>
发布262号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript，这个版本就是1.0版。<br>
该标准从一开始就是针对 JavaScript 语言制定的，但是之所以不叫 JavaScript，有两个原因。</p>
<ul>
<li>一是商标，Java 是 Sun<br>
公司的商标，根据授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且 JavaScript 本身也已经被<br>
Netscape 公司注册为商标。</li>
<li>二是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。</li>
</ul>
<p>因此，ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 Jscript 和 ActionScript）。日常场合，这两个词是可以互换的。<br>
而ECMAScript6就是新一代的JavaScript语言。</p>
<p>这里也强烈推荐大家学习ECMAScript6的时候参考这本书ECMAScript 6入门。</p>
<h4 id="我在学习Vue的时候老是听到Webpack，这是啥？"><a class="header-anchor" href="#我在学习Vue的时候老是听到Webpack，这是啥？">¶</a> 我在学习Vue的时候老是听到Webpack，这是啥？</h4>
<p>Webpack是一个前端打包和构建工具。如果你之前一直是手写HTML，CSS，JavaScript，并且通过link标签将CSS引入你的HTML文件，以及通过Script标签的src属性引入外部的JS脚本，那么你肯定会对这个工具感到陌生。不要紧，我们先来了解一下为什么要用Webpack，然后带着原因去学习就好了。</p>
<h5 id="为什么要用Webpack"><a class="header-anchor" href="#为什么要用Webpack">¶</a> 为什么要用Webpack</h5>
<p>前面说了，做一个单页应用程序本身就相当复杂，而且在做的时候肯定会使用到很多素材和别的第三方库，我们该如何去管理这些东西呢？</p>
<p>还有前面讲到了Webpack是一个前端打包工具，前端代码为什么要打包呢？因为单页应用程序中用到很多素材，如果每一个素材都通过在HTML中以src属性或者link来引入，那么请求一个页面的时候，可能浏览器就要发起十多次请求，往往请求的这些资源都是一些脚本代码或者很小的图片，这些资源本身才几k，下载连1秒都不需要，但是由于HTTP是应用层协议，它的下层是TCP这个运输层协议，TCP的握手和挥手过程消耗的时间可能比下载资源本身还要长，所以需要把这些小文件全部打包成一个文件，这样只要一次TCP握手和挥手的过程，就把多个资源给下载下来了，并且多个资源由于都是共享一个HTTP请求，所以head等部分也是共享的，相当于形成了规模效应，让网页展现更快，用户体验更好。</p>
<p>前面说到Webpack还有构建的功能，这就不得不提到了ECMAScript6这个新版本的JavaScript，但是现在国内外还有很多人用着老版本的浏览器，这些浏览器并不支持ECMAScript6，那么我们的前端项目如何在这种浏览器上运行呢？这就需要Webpack的Loader自动载入一个转换器来将我们写的ECMAScript6转换成浏览器能支持的老版本JavaScript语言，这个转换器的名字叫做babel，如果你以后听到或者看到了这个单词，应该要知道它就是一个ECMAScript6<br>
to 老版本JavaScript的转换器了。这也是Webpack的构建功能。当然对前端有更深入的同学还会知道Sass，Less，stylus之类的CSS预处理器，我们也可以通过在Loader中编写特定的规则来实现自动将这些CSS预处理语言转换成普通浏览器能识别的CSS代码。</p>
<p>开头的介绍提到了vue.js可以使用单文件组件开发项目，其实也是通过Webpack将单文件组件中的模版，样式以及JS转换到主页面中。</p>
<p>当然Webpack不止这点功能，它还可以通过安装各种插件来扩展，比如说热加载技术，就是解放键盘的F5键。让我们修改代码，并且按Ctrl+S保存之后，浏览器页面自动刷新变化，不需要我们去手动刷新，还有一些插件可以自动添加注释，自动给CSS代码加上一些浏览器内核对CSS3兼容前缀，就像webkit-xxx之类的一样。</p>
<h5 id="NPM和Node.js又是什么？它们是什么关系？"><a class="header-anchor" href="#NPM和Node.js又是什么？它们是什么关系？">¶</a> NPM和Node.js又是什么？它们是什么关系？</h5>
<p>首先讲讲Node.js。我们知道通常情况下，JavaScript的运行环境都是浏览器，因此JavaScript的能力也就局限于浏览器能赋予它的权限了。比如说读写本地系统文件这种操作，一般情况下运行在浏览器中的JavaScript代码是没有这个操作权限的。如果我们想用JavaScript写出一些能够运行在操作系统上的，能够具有像PHP，JAVA之类的编程语言具有的功能的程序该怎么办呢？Node.js就解决了这个问题。Node.js是一个服务端的JavaScript运行环境，通过Node.js可以实现用JavaScript写独立程序。像我们之前提到的Webpack就是Node.js写的，所以作为一个前端开发，即使你不用Node.js写独立程序，也得配一个Node.js运行环境，毕竟很多前端工具都是使用它写的。</p>
<p>NPM是一个node.js的包管理器。我们在传统开发的时候，JQuery.js大多都是百度搜索，然后去官网下载，或者直接引入CDN资源，这种方法太过于麻烦。如果以后遇到其他的包，这个包的代码本身可能还调用了其他的包（也称这个包和其他的那几个包存在依赖关系），那么我们要在自己的项目中引入一个包将变得十分困难。现在我们有了NPM这个包管理器，直接可以通过</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install xxx包名称</span><br></pre></td></tr></table></figure>
<p>的方式引入它，比如说</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install vue</span><br></pre></td></tr></table></figure>
<p>就自动在当前项目文件夹下导入了这个包，并且npm自动下载好了vue这个包依赖的其他包。</p>
<p>至于有的人在按照网上的npm教程配置的时候踩坑了，发现下载速度很慢或者完全下载不了，那是因为我国有着众所周知的原因，网上也有各种解决方法可以解决这个问题，大家多善用搜索引擎。</p>
<p>前面提到了Webpack可以安装各种插件来扩展功能，其实也是通过这种方式扩展。<br>
如果你习惯用Linux系统的话，NPM就和CentOS下的yum和Ubuntu下的apt-get差不多。</p>
<h4 id="Vue-CLi又是啥？"><a class="header-anchor" href="#Vue-CLi又是啥？">¶</a> Vue-CLi又是啥？</h4>
<p>它是一个vue.js的脚手架工具。说白了就是一个自动帮你生成好项目目录，配置好Webpack，以及各种依赖包的工具，它可以通过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install vue-cli -g</span><br></pre></td></tr></table></figure>
<p>的方式安装，后面的-g表示全局安装的意思，意味着你可以打开命令行之后直接通过vue命令调用它。</p>
<h4 id="Vue怎么火起来的？"><a class="header-anchor" href="#Vue怎么火起来的？">¶</a> Vue怎么火起来的？</h4>
<blockquote>
<p>Vue的创始人是中国人！中国人！ <br><br>
很多大厂为它背书！为它背书！<br><br>
原生的中文文档！中文文档！<br></p>
</blockquote>
<p>关于这个问题，网上说法很多，我自己认为主要还是前些年大前端变革太快，而最近一年开始Vue.js+Webpack这个组合开始逐渐稳定下来了，而且已经有了很多中文资料。</p>
<p>对比它的竞争对手AngularJS，新旧版本项目无法平滑升级，变革太大让用户感觉不安稳。</p>
<p>而React本身主流推荐用的是JSX，需要额外学习一门语法（什么？学Vue.js还要学ECMAScript6？现在ECMAScript6是趋势，并不是因为Vue.js才要学的），并且React本身用的是render写法编写模版代码，这让很多用习惯了Smarty等后端模版引擎得人来使用感觉很不适应，现在看来React本身在中国一些论坛社区的火爆程度还是没有Vue.js高。</p>
<p>当然也并不是说除了Vue.js以外其他框架都很差。像知乎新版也是用React开发的，他还是有各自优秀的地方大家可以深入学习之后做出自己的判断。</p>
<h4 id="我在很多地方还看到Vuex和Vue-route，它们又是什么？"><a class="header-anchor" href="#我在很多地方还看到Vuex和Vue-route，它们又是什么？">¶</a> 我在很多地方还看到Vuex和Vue-route，它们又是什么？</h4>
<p>Vuex是vue的一个状态管理器。用于集中管理一个单页应用程序中的各种状态。</p>
<p>Vue-route是vue的一个前端路由器，这个路由器不是我们上网用的路由器，而是一个管理请求入口和页面映射关系的东西。它可以实现对页面局部进行无刷新的替换，让用户感觉就像切换到了网页一样。</p>
<p>要讲清楚这两个东西，又得花费大量篇幅，所以这里只是简单提一下，先学好vue.js本身才是最重要的。</p>
<h4 id="Vue-resource和Axios，它们又是什么？"><a class="header-anchor" href="#Vue-resource和Axios，它们又是什么？">¶</a> Vue-resource和Axios，它们又是什么？</h4>
<p>我们在传统的前后端不分离的开发中，后端直接把数据通过模版引擎拼接进了返回的HTML中。而现在做单页应用程序属于前后端分离开发，那么这个单页应用程序中的数据就得通过ajax的方式获取，也要通过ajax的方式提交到后端。</p>
<p>在传统开发中我们都是通过xmlhttprequest手动操作，或者通过JQuery的ajax方法来进行数据提交获取。</p>
<p>vue.js本身没有封装ajax操作库，所以我们要通过Vue-resource和Axios来进行ajax操作，而因为种种原因，现在vue.js2.0已经将axios作为官方推荐的ajax库了。</p>
<h4 id="写Vue.js用什么开发工具和电脑呢？"><a class="header-anchor" href="#写Vue.js用什么开发工具和电脑呢？">¶</a> 写Vue.js用什么开发工具和电脑呢？</h4>
<p>参照我另外一篇文章：<br>
<a href="../58375/">Vue的IDE和项目结构大纲</a></p>
<h2 id="结束语"><a class="header-anchor" href="#结束语">¶</a> 结束语</h2>
<p>可能包括我在内的很多人在看到Vue.js那神奇的双向绑定优雅写法都会有一种非常惊艳，而看到中文文档发布之后有种想立马学习的冲动。可惜大前端终究是大前端，如果一个对于前端各个方面没有深入认识就想着能一步登天，肯定对不起大前端的“大”字。原本看着只想学一个Vue.js，没想到顺带把ECMAScript6，Webpack配置，ESLint配置，bable配置，npm使用，node.js语法，以后vue全家桶中的vuex，vue-route等等等等都学了一遍。前段时间网上也流传出了一个职位叫做Webpack配置工程师，从这里也可以看出弄懂前端这个大杂烩确实不是那么容易。大家一起加油，有什么问题也可以在评论区回复，我会抽空补充在文章内容中。谢谢各位的支持！~</p>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css">]]></content>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title>Facing the Sea With Spring Blossoms</title>
    <url>/43307/</url>
    <content><![CDATA[<p>面朝大海，春暖花开</p>
<p>Haizi</p>
<p>From tomorrow on ,I will be a happy man .</p>
<p>Grooming,chopping and traveling all over the world .</p>
<p>From tomorrow on ,I will care foodstuff and vegetable.</p>
<p>Living in a house toward the sea ,with Spring blossoms.</p>
<p>From tomorrow on ,write to each of my dear ones .</p>
<p>Telling them of my happiness .</p>
<p>What the lightening of happiness has told me .</p>
<p>I Will spread it to each of the them .</p>
<p>Given a warm name</p>
<p>for every river and erery mountain,</p>
<p>Strangers ,I will also wish you happy .</p>
<p>May you have a brilliant futurel.</p>
<p>May you lovers eventually becomes spouses!</p>
<p>May you enjoy happiness in this earthly world !</p>
<p>I only wish to face the sea ,with Spring blossoms.</p>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css">]]></content>
      <categories>
        <category>诗歌</category>
      </categories>
      <tags>
        <tag>诗歌</tag>
      </tags>
  </entry>
  <entry>
    <title>acme.sh快速上手</title>
    <url>/12013/</url>
    <content><![CDATA[<p>acme.sh是一个获取SSL证书的开源项目，可以实现自动申请、续签、安装证书，让网站实现https访问。</p>
<p>本文档侧重于快速上手使用，更多高级用法请查阅acme.sh使用说明或acme.sh官方Wiki。</p>
<h1 id="概述"><a class="header-anchor" href="#概述">¶</a> 概述</h1>
<p>acme.sh是针对ACME协议编写的工具，默认使用的CA是Let’s Encrypt；只要你有域名的控制权，就可以在一分钟内拿到一张有效期三个月的泛域名证书，而acme.sh也可以实现自动申请、续签、安装证书。<br>
对于含有非ASCII字符的域名（例如中文域名），需要先转为 Punycode ，由于Punycode的字符串中含有  – ，使用时务必将整个域名用英文引号括起来，即 <code>&quot;域名&quot;</code> 格式。<br>
对于一个域名，比如 <code>dnomd343.top</code> ，其泛域名证书颁发给 <code>*.dnomd343.top</code>，此时主域名未被包含，因此申请时应同时指定 <code>dnomd343.top</code> 和 <code>*.dnomd343.top</code> 两个域名。<br>
对于多级子域名，主域名的通配符证书并不适用，例如颁发给 <code>*.dnomd343.top</code> 的证书不适用于 <code>test.djnc.dnomd343.top </code>，必须使用颁发给 <code>*.djnc.dnomd343.top</code> 的证书；此外，域名证书最多只支持一个通配符，即不存在 <em>.</em>.dnomd343.top 或类似的证书。</p>
<h2 id="安装acme.sh"><a class="header-anchor" href="#安装acme.sh">¶</a> <a href="http://xn--acme-ke9g492u.sh" target="_blank" rel="noopener">安装acme.sh</a></h2>
<p>acme.sh的安装不需要root权限，安装过程不会污染已有的系统任何功能和文件，所有的修改都被限制在 ~/.acme.sh/ 中<br>
使用如下命令自动安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell&gt; curl https:&#x2F;&#x2F;get.acme.sh | sh</span><br></pre></td></tr></table></figure>
<p>安装完成后，重新连接窗口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell&gt; acme.sh --version</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;acmesh-official&#x2F;acme.sh</span><br><span class="line">v2.8.8</span><br></pre></td></tr></table></figure>
<p>成功输出版本号即安装成功</p>
<h2 id="申请证书"><a class="header-anchor" href="#申请证书">¶</a> 申请证书</h2>
<p>acme.sh有多种证书申请方式，这里只介绍 DNS API模式 ，这个模式只需要提供域名服务商分配给你账号的凭证，acme.sh会自动用它自动申请、续签证书，整个过程无需用户干预，只要你的服务器能访问网络就可以拿到证书。<br>
大部分域名服务商都会给用户提供API接口方便程序操作，其凭证一般称为 API Key ，acme.sh的文档中列出百余家服务商的使用方法。<br>
这里以阿里云为例，申请 dnomd343.top 的全部证书；首先在阿里云AccessKey控制台拿到用户的 AccessKey ID 和 AccessKey Secret，然后执行如下命令：</p>
<h3 id="阿里云域名访问的AccessKey"><a class="header-anchor" href="#阿里云域名访问的AccessKey">¶</a> 阿里云域名访问的AccessKey</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell&gt; export Ali_Key&#x3D;&quot;···&quot;</span><br><span class="line">shell&gt; export Ali_Secret&#x3D;&quot;···&quot;</span><br></pre></td></tr></table></figure>
<h3 id="申请主域名证书和泛域名证书"><a class="header-anchor" href="#申请主域名证书和泛域名证书">¶</a> 申请主域名证书和泛域名证书</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell&gt; acme.sh --issue --dns dns_ali -d dnomd343.top -d *.dnomd343.top</span><br><span class="line">···</span><br><span class="line">Cert success.</span><br><span class="line">···</span><br><span class="line">Your cert is in  &#x2F;home&#x2F;dnomd343&#x2F;.acme.sh&#x2F;dnomd343.top&#x2F;dnomd343.top.cer</span><br><span class="line">Your cert key is in  &#x2F;home&#x2F;dnomd343&#x2F;.acme.sh&#x2F;dnomd343.top&#x2F;dnomd343.top.key</span><br><span class="line">The intermediate CA cert is in  &#x2F;home&#x2F;dnomd343&#x2F;.acme.sh&#x2F;dnomd343.top&#x2F;ca.cer</span><br><span class="line">And the full chain certs is there:  &#x2F;home&#x2F;dnomd343&#x2F;.acme.sh&#x2F;dnomd343.top&#x2F;fullchain.cer</span><br></pre></td></tr></table></figure>
<p>此时证书申请成功，文件放置在 <code>/home/dnomd343/.acme.sh/dnomd343.top </code>下面。</p>
<h2 id="安装证书"><a class="header-anchor" href="#安装证书">¶</a> 安装证书</h2>
<p>注意：不要直接用 .acme.sh/内的证书文件，里面目录结构随使可能会因为脚本自动更新而变动。<br>
下面以nginx证书安装为例：</p>
<h4 id="配置nginx"><a class="header-anchor" href="#配置nginx">¶</a> 配置nginx</h4>
<p>存放配置的文件夹一般为 /etc/nginx/conf.d/，在其下新建 dnomd343.conf 文件；</p>
<p>下面配置文件将 dnomd343.top 映射到 /var/www/dnomd343/ 目录下，使用 /etc/ssl/certs/dnomd343.top 下的证书文件配置https，并强制将http重写到https。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80; # 监听80端口(http)</span><br><span class="line">    server_name dnomd343.top;</span><br><span class="line">    return 301 https:&#x2F;&#x2F;$server_name$request_uri; # 返回301命令，将地址重写到https上</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl; # 监听443端口(https)</span><br><span class="line">    server_name dnomd343.top;</span><br><span class="line">    root &#x2F;var&#x2F;www&#x2F;dnomd343; # 指定网站根目录</span><br><span class="line">    ssl_certificate &#x2F;etc&#x2F;ssl&#x2F;certs&#x2F;dnomd343.top&#x2F;fullchain.pem; # 指定SSL&#x2F;TLS证书</span><br><span class="line">    ssl_certificate_key &#x2F;etc&#x2F;ssl&#x2F;certs&#x2F;dnomd343.top&#x2F;privkey.pem;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        index index.html; # 默认加载文件</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 dnomd343.top 域名解析中，配置 @ 的 A 记录指向本机的IP地址。<br>
注意，请确认你的服务器防火墙是否拦截 80 和 443 端口，包括云服务商提供的防火墙和系统上安装的防火墙。<br>
给nginx安装<br>
将证书安装到 /etc/ssl/certs/dnomd343.top 下，并配置nginx的重启命令<br>
查看证书申请状态：</p>
<h3 id="列出全部证书"><a class="header-anchor" href="#列出全部证书">¶</a> 列出全部证书</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell&gt; acme.sh --list</span><br><span class="line">Main_Domain   KeyLength  SAN_Domains     CA               Created   Renew</span><br><span class="line">dnomd343.top  &quot;&quot;         *.dnomd343.top  LetsEncrypt.org  ···</span><br></pre></td></tr></table></figure>
<p>安装证书到nginx，安装完成后会重启nginx使命令生效。</p>
<h3 id="创建文件夹"><a class="header-anchor" href="#创建文件夹">¶</a> 创建文件夹</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell&gt; mkdir -p &#x2F;etc&#x2F;ssl&#x2F;certs&#x2F;dnomd343.top&#x2F;</span><br></pre></td></tr></table></figure>
<h1 id="安装证书-2"><a class="header-anchor" href="#安装证书-2">¶</a> 安装证书</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell&gt; acme.sh --install-cert -d dnomd343.top  \</span><br><span class="line">--key-file       &#x2F;etc&#x2F;ssl&#x2F;certs&#x2F;dnomd343.top&#x2F;privkey.pem \</span><br><span class="line">--fullchain-file &#x2F;etc&#x2F;ssl&#x2F;certs&#x2F;dnomd343.top&#x2F;fullchain.pem  \</span><br><span class="line">--reloadcmd      &quot;systemctl force-reload nginx&quot;</span><br><span class="line">···</span><br><span class="line">Installing key to:&#x2F;etc&#x2F;ssl&#x2F;certs&#x2F;dnomd343.top&#x2F;privkey.pem</span><br><span class="line">Installing full chain to:&#x2F;etc&#x2F;ssl&#x2F;certs&#x2F;dnomd343.top&#x2F;fullchain.pem</span><br><span class="line">Run reload cmd: systemctl force-reload nginx</span><br><span class="line">Reload success</span><br></pre></td></tr></table></figure>
<p>为了确保服务启动成功，可以查看nginx监听端口的状态</p>
<h3 id="查看80端口(http)状态"><a class="header-anchor" href="#查看80端口(http)状态">¶</a> 查看80端口(http)状态</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell&gt; netstat -tlnp | grep 80</span><br><span class="line">tcp     0     0 0.0.0.0:80       0.0.0.0:*     LISTEN      7227&#x2F;nginx: master</span><br><span class="line">tcp6    0     0 :::80            :::*          LISTEN      7227&#x2F;nginx: master</span><br></pre></td></tr></table></figure>
<h3 id="查看443端口(https)状态"><a class="header-anchor" href="#查看443端口(https)状态">¶</a> 查看443端口(https)状态</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell&gt; netstat -tlnp | grep 443</span><br><span class="line">tcp     0     0 0.0.0.0:443      0.0.0.0:*     LISTEN      7227&#x2F;nginx: master</span><br></pre></td></tr></table></figure>
<p>若上述命令均未报错，则证书安装成功，访问 <a href="https://dnomd343.com/" target="_blank" rel="noopener">https://dnomd343.com/</a> 确认是否配置成功。</p>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css">]]></content>
      <tags>
        <tag>HTTPS</tag>
        <tag>网站证书</tag>
        <tag>acme</tag>
      </tags>
  </entry>
  <entry>
    <title>VUE的IDE推荐和项目结构大纲</title>
    <url>/58375/</url>
    <content><![CDATA[<h2 id="IDE工具推荐"><a class="header-anchor" href="#IDE工具推荐">¶</a> IDE工具推荐</h2>
<p>HBuilderX<br>
Visual Studio Code<br>
其中HBuilderX是中国人开发的IDE良心作品！！！</p>
<h2 id="项目结构大纲"><a class="header-anchor" href="#项目结构大纲">¶</a> 项目结构大纲</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|-- build                            &#x2F;&#x2F; 项目构建(webpack)相关代码</span><br><span class="line">|   |-- build.js                     &#x2F;&#x2F; 生产环境构建代码</span><br><span class="line">|   |-- check-version.js             &#x2F;&#x2F; 检查node、npm等版本</span><br><span class="line">|   |-- dev-client.js                &#x2F;&#x2F; 热重载相关</span><br><span class="line">|   |-- dev-server.js                &#x2F;&#x2F; 构建本地服务器</span><br><span class="line">|   |-- utils.js                     &#x2F;&#x2F; 构建工具相关</span><br><span class="line">|   |-- webpack.base.conf.js         &#x2F;&#x2F; webpack基础配置</span><br><span class="line">|   |-- webpack.dev.conf.js          &#x2F;&#x2F; webpack开发环境配置</span><br><span class="line">|   |-- webpack.prod.conf.js         &#x2F;&#x2F; webpack生产环境配置</span><br><span class="line">|-- config                           &#x2F;&#x2F; 项目开发环境配置</span><br><span class="line">|   |-- dev.env.js                   &#x2F;&#x2F; 开发环境变量</span><br><span class="line">|   |-- index.js                     &#x2F;&#x2F; 项目一些配置变量</span><br><span class="line">|   |-- prod.env.js                  &#x2F;&#x2F; 生产环境变量</span><br><span class="line">|   |-- test.env.js                  &#x2F;&#x2F; 测试环境变量</span><br><span class="line">|-- src                              &#x2F;&#x2F; 源码目录</span><br><span class="line">|   |-- components                   &#x2F;&#x2F; vue公共组件</span><br><span class="line">|   |-- store                        &#x2F;&#x2F; vuex的状态管理</span><br><span class="line">|   |-- App.vue                      &#x2F;&#x2F; 页面入口文件</span><br><span class="line">|   |-- main.js                      &#x2F;&#x2F; 程序入口文件，加载各种公共组件</span><br><span class="line">|-- static                           &#x2F;&#x2F; 静态文件，比如一些图片，json数据等</span><br><span class="line">|   |-- data                         &#x2F;&#x2F; 群聊分析得到的数据用于数据可视化</span><br><span class="line">|-- .babelrc                         &#x2F;&#x2F; ES6语法编译配置</span><br><span class="line">|-- .editorconfig                    &#x2F;&#x2F; 定义代码格式</span><br><span class="line">|-- .gitignore                       &#x2F;&#x2F; git上传需要忽略的文件格式</span><br><span class="line">|-- README.md                        &#x2F;&#x2F; 项目说明</span><br><span class="line">|-- favicon.ico </span><br><span class="line">|-- index.html                       &#x2F;&#x2F; 入口页面</span><br><span class="line">|-- package.json                     &#x2F;&#x2F; 项目基本信息</span><br></pre></td></tr></table></figure>
<h3 id="vue-cli项目结构配置文件详细描述"><a class="header-anchor" href="#vue-cli项目结构配置文件详细描述">¶</a> vue-cli项目结构配置文件详细描述</h3>
<p><code>package.json</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这里包含开发运行，项目打包，单元测试等命令，测试的东西先放一边，</span><br><span class="line">看dev和build命令。运行”npm run dev”的时候执行的是build&#x2F;dev-server.js文件，</span><br><span class="line">运行”npm run build”的时候执行的是build&#x2F;build.js文件，我们可以从这两个文件开始进行代码阅读分析。</span><br><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">&quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build&#x2F;webpack.dev.conf.js&quot;,</span><br><span class="line">&quot;start&quot;: &quot;npm run dev&quot;,</span><br><span class="line">&quot;lint&quot;: &quot;eslint --ext .js,.vue src&quot;,</span><br><span class="line">&quot;build&quot;: &quot;node build&#x2F;build.js&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h3 id="build文件夹分析"><a class="header-anchor" href="#build文件夹分析">¶</a> build文件夹分析</h3>
<p><code>build/build.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 这里包含了：</span><br><span class="line">	&#x2F;&#x2F;loading动画；</span><br><span class="line">	&#x2F;&#x2F;删除目标文件夹；</span><br><span class="line">	&#x2F;&#x2F;执行webpack构建；</span><br><span class="line">	&#x2F;&#x2F;输出信息；</span><br><span class="line">	&#x2F;&#x2F;webpack编译之后会输出到配置里面指定的目标文件夹；删除目标文件夹之后再创建是为了去除旧的内容，</span><br><span class="line">	&#x2F;&#x2F;以免产生不可预测的影响。</span><br><span class="line">&#39;use strict&#39;</span><br><span class="line">&#x2F;&#x2F; 检查NodeJS和npm的版本。</span><br><span class="line">require(&#39;.&#x2F;check-versions&#39;)()</span><br><span class="line">process.env.NODE_ENV &#x3D; &#39;production&#39;</span><br><span class="line">&#x2F;&#x2F; ora插件，实现node.js命令行环境的loading效果和显示各种状态的图标等。</span><br><span class="line">const ora &#x3D; require(&#39;ora&#39;)</span><br><span class="line">&#x2F;&#x2F; rimraf插件，每次启动编译或者打包之前，先把整个dist文件夹删除，然后再重新生成dist。</span><br><span class="line">const rm &#x3D; require(&#39;rimraf&#39;)</span><br><span class="line">const path &#x3D; require(&#39;path&#39;)</span><br><span class="line">&#x2F;&#x2F; 用于在控制台输出带颜色字体的插件。</span><br><span class="line">const chalk &#x3D; require(&#39;chalk&#39;)</span><br><span class="line">const webpack &#x3D; require(&#39;webpack&#39;)</span><br><span class="line">const config &#x3D; require(&#39;..&#x2F;config&#39;)</span><br><span class="line">const webpackConfig &#x3D; require(&#39;.&#x2F;webpack.prod.conf&#39;)</span><br><span class="line">const spinner &#x3D; ora(&#39;building for production...&#39;)</span><br><span class="line">spinner.start()</span><br><span class="line">rm(path.join(config.build.assetsRoot, config.build.assetsSubDirectory), err &#x3D;&gt; &#123;</span><br><span class="line">if (err) throw err</span><br><span class="line">webpack(webpackConfig, (err, stats) &#x3D;&gt; &#123;</span><br><span class="line">    spinner.stop()</span><br><span class="line">    if (err) throw err</span><br><span class="line">    process.stdout.write(stats.toString(&#123;</span><br><span class="line">    colors: true,</span><br><span class="line">    modules: false,</span><br><span class="line">    children: false, &#x2F;&#x2F; If you are using ts-loader, setting this to true will make TypeScript errors show up during build.</span><br><span class="line">    chunks: false,</span><br><span class="line">    chunkModules: false</span><br><span class="line">    &#125;) + &#39;\n\n&#39;)</span><br><span class="line">    if (stats.hasErrors()) &#123;</span><br><span class="line">    console.log(chalk.red(&#39;  Build failed with errors.\n&#39;))</span><br><span class="line">    process.exit(1)</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(chalk.cyan(&#39;  Build complete.\n&#39;))</span><br><span class="line">    console.log(chalk.yellow(</span><br><span class="line">    &#39;  Tip: built files are meant to be served over an HTTP server.\n&#39; +</span><br><span class="line">    &#39;  Opening index.html over file:&#x2F;&#x2F; won\&#39;t work.\n&#39;</span><br><span class="line">    ))</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>build/check-versions.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这里完成对node和npm的版本检测。</span><br><span class="line">&#39;use strict&#39;</span><br><span class="line">&#x2F;&#x2F; 用于在控制台输出带颜色字体的插件。</span><br><span class="line">const chalk &#x3D; require(&#39;chalk&#39;)</span><br><span class="line">&#x2F;&#x2F; 语义化版本检查插件。</span><br><span class="line">const semver &#x3D; require(&#39;semver&#39;)</span><br><span class="line">&#x2F;&#x2F; 引入package.json。</span><br><span class="line">const packageConfig &#x3D; require(&#39;..&#x2F;package.json&#39;)</span><br><span class="line">const shell &#x3D; require(&#39;shelljs&#39;)</span><br><span class="line">&#x2F;&#x2F; 开辟子进程执行指令cmd并返回结果。</span><br><span class="line">function exec (cmd) &#123;</span><br><span class="line">return require(&#39;child_process&#39;).execSync(cmd).toString().trim()</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; node和npm版本需求。</span><br><span class="line">const versionRequirements &#x3D; [</span><br><span class="line">&#123;</span><br><span class="line">    name: &#39;node&#39;,</span><br><span class="line">    currentVersion: semver.clean(process.version),</span><br><span class="line">    versionRequirement: packageConfig.engines.node</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">if (shell.which(&#39;npm&#39;)) &#123;</span><br><span class="line">versionRequirements.push(&#123;</span><br><span class="line">    name: &#39;npm&#39;,</span><br><span class="line">    currentVersion: exec(&#39;npm --version&#39;),</span><br><span class="line">    versionRequirement: packageConfig.engines.npm</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">module.exports &#x3D; function () &#123;</span><br><span class="line">const warnings &#x3D; []</span><br><span class="line">&#x2F;&#x2F; 依次判断版本是否符合要求。</span><br><span class="line">for (let i &#x3D; 0; i &lt; versionRequirements.length; i++) &#123;</span><br><span class="line">    const mod &#x3D; versionRequirements[i]</span><br><span class="line">    if (!semver.satisfies(mod.currentVersion, mod.versionRequirement)) &#123;</span><br><span class="line">    warnings.push(mod.name + &#39;: &#39; +</span><br><span class="line">        chalk.red(mod.currentVersion) + &#39; should be &#39; +</span><br><span class="line">        chalk.green(mod.versionRequirement)</span><br><span class="line">    )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 如果有警告则将其输出到控制台。</span><br><span class="line">if (warnings.length) &#123;</span><br><span class="line">    console.log(&#39;&#39;)</span><br><span class="line">    console.log(chalk.yellow(&#39;To use this template, you must update following to modules:&#39;))</span><br><span class="line">    console.log()</span><br><span class="line">    for (let i &#x3D; 0; i &lt; warnings.length; i++) &#123;</span><br><span class="line">    const warning &#x3D; warnings[i]</span><br><span class="line">    console.log(&#39;  &#39; + warning)</span><br><span class="line">    &#125;</span><br><span class="line">    console.log()</span><br><span class="line">    process.exit(1)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>build/utils.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这里提供工具函数，包括生成处理各种样式语言的loader，获取资源文件存放路径的工具函数。</span><br><span class="line">配置静态资源路径；</span><br><span class="line">生成cssLoaders用于加载.vue文件中的样式；</span><br><span class="line">生成styleLoaders用于加载不在.vue文件中的单独存在的样式文件。</span><br></pre></td></tr></table></figure>
<p><code>build/vue-loader.conf.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这里负责处理.vue文件中的样式，配置css加载器以及编译css之后自动添加前缀。</span><br><span class="line">&#39;use strict&#39;</span><br><span class="line">const utils &#x3D; require(&#39;.&#x2F;utils&#39;)</span><br><span class="line">const config &#x3D; require(&#39;..&#x2F;config&#39;)</span><br><span class="line">const isProduction &#x3D; process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39;</span><br><span class="line">const sourceMapEnabled &#x3D; isProduction</span><br><span class="line">? config.build.productionSourceMap</span><br><span class="line">: config.dev.cssSourceMap</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">&#x2F;&#x2F; css加载器。</span><br><span class="line">loaders: utils.cssLoaders(&#123;</span><br><span class="line">    sourceMap: sourceMapEnabled,</span><br><span class="line">    extract: isProduction</span><br><span class="line">&#125;),</span><br><span class="line">cssSourceMap: sourceMapEnabled,</span><br><span class="line">cacheBusting: config.dev.cacheBusting,</span><br><span class="line">&#x2F;&#x2F; 让vue-loader知道需要对video的src属性的内容转换为模块。</span><br><span class="line">transformToRequire: &#123;</span><br><span class="line">    video: [&#39;src&#39;, &#39;poster&#39;],</span><br><span class="line">    source: &#39;src&#39;,</span><br><span class="line">    img: &#39;src&#39;,</span><br><span class="line">    image: &#39;xlink:href&#39;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>build/webpack.base.conf.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这里这个配置里面只配置了.js、.vue、图片、字体等几类文件的处理规则，如果需要处理其他文件可以在module.rules里面另行配置。从代码中看到，dev-server使用的webpack配置来自build&#x2F;webpack.dev.conf.js文件（测试环境下使用的是build&#x2F;webpack.prod.conf.js，这里暂时不考虑测试环境）。而build&#x2F;webpack.dev.conf.js中又引用了webpack.base.conf.js，所以这里先看webpack.base.conf.js。</span><br><span class="line">webpack.base.conf.js主要完成下面的操作：</span><br><span class="line">配置webpack编译入口；</span><br><span class="line">配置webpack输出路径和命名规则；</span><br><span class="line">配置模块resolve规则；</span><br><span class="line">配置不同类型模块的处理规则。</span><br><span class="line">&#39;use strict&#39;</span><br><span class="line">const path &#x3D; require(&#39;path&#39;)</span><br><span class="line">const utils &#x3D; require(&#39;.&#x2F;utils&#39;)</span><br><span class="line">const config &#x3D; require(&#39;..&#x2F;config&#39;)</span><br><span class="line">const vueLoaderConfig &#x3D; require(&#39;.&#x2F;vue-loader.conf&#39;)</span><br><span class="line">&#x2F;&#x2F; 给出正确的绝对路径。</span><br><span class="line">function resolve (dir) &#123;</span><br><span class="line">return path.join(__dirname, &#39;..&#39;, dir)</span><br><span class="line">&#125;</span><br><span class="line">const createLintingRule &#x3D; () &#x3D;&gt; (&#123;</span><br><span class="line">test: &#x2F;\.(js|vue)$&#x2F;,</span><br><span class="line">loader: &#39;eslint-loader&#39;,</span><br><span class="line">enforce: &#39;pre&#39;,</span><br><span class="line">include: [resolve(&#39;src&#39;), resolve(&#39;test&#39;)],</span><br><span class="line">options: &#123;</span><br><span class="line">    formatter: require(&#39;eslint-friendly-formatter&#39;),</span><br><span class="line">    emitWarning: !config.dev.showEslintErrorsInOverlay</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">context: path.resolve(__dirname, &#39;..&#x2F;&#39;),</span><br><span class="line">entry: &#123;</span><br><span class="line">    &#x2F;&#x2F; 配置webpack编译入口。</span><br><span class="line">    app: &#39;.&#x2F;src&#x2F;main.js&#39;</span><br><span class="line">&#125;,</span><br><span class="line">&#x2F;&#x2F; 配置webpack输出路径和命名规则。</span><br><span class="line">output: &#123;</span><br><span class="line">    &#x2F;&#x2F; webpack输出的目标文件夹路径（例如：&#x2F;dist）</span><br><span class="line">    path: config.build.assetsRoot,</span><br><span class="line">    &#x2F;&#x2F; webpack输出bundle文件命名格式。</span><br><span class="line">    filename: &#39;[name].js&#39;,</span><br><span class="line">    &#x2F;&#x2F; webpack编译输出的发布路径。</span><br><span class="line">    publicPath: process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39;</span><br><span class="line">    ? config.build.assetsPublicPath</span><br><span class="line">    : config.dev.assetsPublicPath</span><br><span class="line">&#125;,</span><br><span class="line">&#x2F;&#x2F; 配置模块resolve的规则。</span><br><span class="line">resolve: &#123;</span><br><span class="line">    &#x2F;&#x2F; 自动resolve的扩展名。</span><br><span class="line">    extensions: [&#39;.js&#39;, &#39;.vue&#39;, &#39;.json&#39;],</span><br><span class="line">    &#x2F;&#x2F; 创建路径别名，有了别名之后引用模块更方便，例如：import Vue from &#39;vue&#x2F;dist&#x2F;vue.esm.js&#39;可以写成 import Vue from &#39;vue&#39;。</span><br><span class="line">    alias: &#123;</span><br><span class="line">    &#39;vue$&#39;: &#39;vue&#x2F;dist&#x2F;vue.esm.js&#39;,</span><br><span class="line">    &#39;@&#39;: resolve(&#39;src&#39;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#x2F;&#x2F; 配置不同类型模块的处理规则。</span><br><span class="line">module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">    ...(config.dev.useEslint ? [createLintingRule()] : []),</span><br><span class="line">    &#x2F;&#x2F; 对所有.vue文件使用vue-loader</span><br><span class="line">    &#123;</span><br><span class="line">        test: &#x2F;\.vue$&#x2F;,</span><br><span class="line">        loader: &#39;vue-loader&#39;,</span><br><span class="line">        options: vueLoaderConfig</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 对src和test文件夹下的.js文件使用babel-loader。</span><br><span class="line">    &#123;</span><br><span class="line">        test: &#x2F;\.js$&#x2F;,</span><br><span class="line">        loader: &#39;babel-loader&#39;,</span><br><span class="line">        include: [resolve(&#39;src&#39;), resolve(&#39;test&#39;), resolve(&#39;node_modules&#x2F;webpack-dev-server&#x2F;client&#39;)]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 对图片资源文件使用url-loader，name指明了输出的命名规则。</span><br><span class="line">    &#123;</span><br><span class="line">        test: &#x2F;\.(png|jpe?g|gif|svg)(\?.*)?$&#x2F;,</span><br><span class="line">        loader: &#39;url-loader&#39;,</span><br><span class="line">        options: &#123;</span><br><span class="line">        limit: 10000,</span><br><span class="line">        name: utils.assetsPath(&#39;img&#x2F;[name].[hash:7].[ext]&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 对媒体资源文件使用url-loader，name指明了输出的命名规则。</span><br><span class="line">    &#123;</span><br><span class="line">        test: &#x2F;\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$&#x2F;,</span><br><span class="line">        loader: &#39;url-loader&#39;,</span><br><span class="line">        options: &#123;</span><br><span class="line">        limit: 10000,</span><br><span class="line">        name: utils.assetsPath(&#39;media&#x2F;[name].[hash:7].[ext]&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 对字体资源文件使用url-loader，name指明了输出的命名规则。</span><br><span class="line">    &#123;</span><br><span class="line">        test: &#x2F;\.(woff2?|eot|ttf|otf)(\?.*)?$&#x2F;,</span><br><span class="line">        loader: &#39;url-loader&#39;,</span><br><span class="line">        options: &#123;</span><br><span class="line">        limit: 10000,</span><br><span class="line">        name: utils.assetsPath(&#39;fonts&#x2F;[name].[hash:7].[ext]&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br><span class="line">node: &#123;</span><br><span class="line">    &#x2F;&#x2F; prevent webpack from injecting useless setImmediate polyfill because Vue</span><br><span class="line">    &#x2F;&#x2F; source contains it (although only uses it if it&#39;s native).</span><br><span class="line">    setImmediate: false,</span><br><span class="line">    &#x2F;&#x2F; prevent webpack from injecting mocks to Node native modules</span><br><span class="line">    &#x2F;&#x2F; that does not make sense for the client</span><br><span class="line">    dgram: &#39;empty&#39;,</span><br><span class="line">    fs: &#39;empty&#39;,</span><br><span class="line">    net: &#39;empty&#39;,</span><br><span class="line">    tls: &#39;empty&#39;,</span><br><span class="line">    child_process: &#39;empty&#39;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>build/webpack.dev.conf.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这里面在webpack.base.conf的基础上增加完善了开发环境下面的配置，主要完成下面操作：</span><br><span class="line">将webpack的热重载客户端代码添加到每个entry对应的应用；</span><br><span class="line">合并基础的webpack配置；</span><br><span class="line">配置样式文件的处理规则，styleLoaders；</span><br><span class="line">配置Source Maps；</span><br><span class="line">配置webpack插件。</span><br><span class="line">&#39;use strict&#39;</span><br><span class="line">const utils &#x3D; require(&#39;.&#x2F;utils&#39;)</span><br><span class="line">const webpack &#x3D; require(&#39;webpack&#39;)</span><br><span class="line">const config &#x3D; require(&#39;..&#x2F;config&#39;)</span><br><span class="line">&#x2F;&#x2F; 一个可以合并数组和对象的插件。</span><br><span class="line">const merge &#x3D; require(&#39;webpack-merge&#39;)</span><br><span class="line">const path &#x3D; require(&#39;path&#39;)</span><br><span class="line">const baseWebpackConfig &#x3D; require(&#39;.&#x2F;webpack.base.conf&#39;)</span><br><span class="line">const CopyWebpackPlugin &#x3D; require(&#39;copy-webpack-plugin&#39;)</span><br><span class="line">&#x2F;&#x2F; 一个用于生成HTML文件并自动注入依赖文件（link&#x2F;script）的webpack插件。</span><br><span class="line">const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;)</span><br><span class="line">&#x2F;&#x2F; 用于更友好地输出webpack的警告、错误等信息。</span><br><span class="line">const FriendlyErrorsPlugin &#x3D; require(&#39;friendly-errors-webpack-plugin&#39;)</span><br><span class="line">const portfinder &#x3D; require(&#39;portfinder&#39;)</span><br><span class="line">const HOST &#x3D; process.env.HOST</span><br><span class="line">const PORT &#x3D; process.env.PORT &amp;&amp; Number(process.env.PORT)</span><br><span class="line">&#x2F;&#x2F; 合并基础的webpack配置。</span><br><span class="line">const devWebpackConfig &#x3D; merge(baseWebpackConfig, &#123;</span><br><span class="line">module: &#123;</span><br><span class="line">    &#x2F;&#x2F; 配置样式文件的处理规则，使用styleLoaders。</span><br><span class="line">    rules: utils.styleLoaders(&#123; sourceMap: config.dev.cssSourceMap, usePostCSS: true &#125;)</span><br><span class="line">&#125;,</span><br><span class="line">&#x2F;&#x2F; 配置Source Maps。在开发中使用cheap-module-eval-source-map更快</span><br><span class="line">devtool: config.dev.devtool。</span><br><span class="line">devServer: &#123;</span><br><span class="line">    clientLogLevel: &#39;warning&#39;,</span><br><span class="line">    historyApiFallback: &#123;</span><br><span class="line">    rewrites: [</span><br><span class="line">        &#123; from: &#x2F;.*&#x2F;, to: path.posix.join(config.dev.assetsPublicPath, &#39;index.html&#39;) &#125;,</span><br><span class="line">    ],</span><br><span class="line">    &#125;,</span><br><span class="line">    hot: true,</span><br><span class="line">    contentBase: false,</span><br><span class="line">    compress: true,</span><br><span class="line">    host: HOST || config.dev.host,</span><br><span class="line">    &#x2F;&#x2F; dev-server 监听的端口，默认为config.dev.port设置的端口，即8080。</span><br><span class="line">    port: PORT || config.dev.port,</span><br><span class="line">    &#x2F;&#x2F; 用于判断是否要自动打开浏览器的布尔变量，当配置文件中没有设置自动打开浏览器的时候其值为 false。</span><br><span class="line">    open: config.dev.autoOpenBrowser,</span><br><span class="line">    overlay: config.dev.errorOverlay</span><br><span class="line">    ? &#123; warnings: false, errors: true &#125;</span><br><span class="line">    : false,</span><br><span class="line">    publicPath: config.dev.assetsPublicPath,</span><br><span class="line">    &#x2F;&#x2F; 定义 HTTP 代理表，代理到 API 服务器。</span><br><span class="line">    proxy: config.dev.proxyTable,</span><br><span class="line">    quiet: true, &#x2F;&#x2F; necessary for FriendlyErrorsPlugin</span><br><span class="line">    watchOptions: &#123;</span><br><span class="line">    poll: config.dev.poll,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#x2F;&#x2F; 配置webpack插件。</span><br><span class="line">plugins: [</span><br><span class="line">    new webpack.DefinePlugin(&#123;</span><br><span class="line">    &#39;process.env&#39;: require(&#39;..&#x2F;config&#x2F;dev.env&#39;)</span><br><span class="line">    &#125;),</span><br><span class="line">    new webpack.HotModuleReplacementPlugin(),</span><br><span class="line">    new webpack.NamedModulesPlugin(), &#x2F;&#x2F; HMR shows correct file names in console on update.</span><br><span class="line">    &#x2F;&#x2F; 页面中的报错不会阻塞，但是会在编译结束后报错。</span><br><span class="line">    new webpack.NoEmitOnErrorsPlugin(),</span><br><span class="line">    &#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;ampedandwired&#x2F;html-webpack-plugin</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">    filename: &#39;index.html&#39;,</span><br><span class="line">    template: &#39;index.html&#39;,</span><br><span class="line">    inject: true</span><br><span class="line">    &#125;),</span><br><span class="line">    &#x2F;&#x2F; copy custom static assets</span><br><span class="line">    new CopyWebpackPlugin([</span><br><span class="line">    &#123;</span><br><span class="line">        from: path.resolve(__dirname, &#39;..&#x2F;static&#39;),</span><br><span class="line">        to: config.dev.assetsSubDirectory,</span><br><span class="line">        ignore: [&#39;.*&#39;]</span><br><span class="line">    &#125;</span><br><span class="line">    ])</span><br><span class="line">]</span><br><span class="line">&#125;)</span><br><span class="line">module.exports &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">portfinder.basePort &#x3D; process.env.PORT || config.dev.port</span><br><span class="line">portfinder.getPort((err, port) &#x3D;&gt; &#123;</span><br><span class="line">    if (err) &#123;</span><br><span class="line">    reject(err)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    process.env.PORT &#x3D; port</span><br><span class="line">    devWebpackConfig.devServer.port &#x3D; port</span><br><span class="line">    devWebpackConfig.plugins.push(new FriendlyErrorsPlugin(&#123;</span><br><span class="line">        compilationSuccessInfo: &#123;</span><br><span class="line">        messages: [&#96;Your application is running here: http:&#x2F;&#x2F;$&#123;devWebpackConfig.devServer.host&#125;:$&#123;port&#125;&#96;],</span><br><span class="line">        &#125;,</span><br><span class="line">        onErrors: config.dev.notifyOnErrors</span><br><span class="line">        ? utils.createNotifierCallback()</span><br><span class="line">        : undefined</span><br><span class="line">    &#125;))</span><br><span class="line">    resolve(devWebpackConfig)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>build/webpack.prod.conf.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这里是构建的时候用到的webpack配置来自webpack.prod.conf.js，该配置同样是在webpack.base.conf基础上的进一步完善。主要完成下面操作：</span><br><span class="line">合并基础的webpack配置；</span><br><span class="line">配置样式文件的处理规则，styleLoaders；</span><br><span class="line">配置webpack的输出；</span><br><span class="line">配置webpack插件；</span><br><span class="line">gzip模式下的webpack插件配置；</span><br><span class="line">webpack-bundle分析。</span><br><span class="line">&#39;use strict&#39;</span><br><span class="line">const path &#x3D; require(&#39;path&#39;)</span><br><span class="line">const utils &#x3D; require(&#39;.&#x2F;utils&#39;)</span><br><span class="line">const webpack &#x3D; require(&#39;webpack&#39;)</span><br><span class="line">const config &#x3D; require(&#39;..&#x2F;config&#39;)</span><br><span class="line">const merge &#x3D; require(&#39;webpack-merge&#39;)</span><br><span class="line">const baseWebpackConfig &#x3D; require(&#39;.&#x2F;webpack.base.conf&#39;)</span><br><span class="line">const CopyWebpackPlugin &#x3D; require(&#39;copy-webpack-plugin&#39;)</span><br><span class="line">const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;)</span><br><span class="line">&#x2F;&#x2F; 用于从webpack生成的bundle中提取文本到特定文件中的插件，可以抽取出css，js文件将其与webpack输出的bundle分离。</span><br><span class="line">const ExtractTextPlugin &#x3D; require(&#39;extract-text-webpack-plugin&#39;)</span><br><span class="line">const OptimizeCSSPlugin &#x3D; require(&#39;optimize-css-assets-webpack-plugin&#39;)</span><br><span class="line">const UglifyJsPlugin &#x3D; require(&#39;uglifyjs-webpack-plugin&#39;)</span><br><span class="line">const env &#x3D; require(&#39;..&#x2F;config&#x2F;prod.env&#39;)</span><br><span class="line">&#x2F;&#x2F; 合并基础的webpack配置。</span><br><span class="line">const webpackConfig &#x3D; merge(baseWebpackConfig, &#123;</span><br><span class="line">module: &#123;</span><br><span class="line">    rules: utils.styleLoaders(&#123;</span><br><span class="line">    sourceMap: config.build.productionSourceMap,</span><br><span class="line">    extract: true,</span><br><span class="line">    usePostCSS: true</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br><span class="line">devtool: config.build.productionSourceMap ? config.build.devtool : false,</span><br><span class="line">&#x2F;&#x2F; 配置webpack的输出。</span><br><span class="line">output: &#123;</span><br><span class="line">    &#x2F;&#x2F; 编译输出目录。</span><br><span class="line">    path: config.build.assetsRoot,</span><br><span class="line">    &#x2F;&#x2F; 编译输出文件名格式。</span><br><span class="line">    filename: utils.assetsPath(&#39;js&#x2F;[name].[chunkhash].js&#39;),</span><br><span class="line">    &#x2F;&#x2F; 没有指定输出名的文件输出的文件名格式。</span><br><span class="line">    chunkFilename: utils.assetsPath(&#39;js&#x2F;[id].[chunkhash].js&#39;)</span><br><span class="line">&#125;,</span><br><span class="line">&#x2F;&#x2F; 配置webpack插件。</span><br><span class="line">plugins: [</span><br><span class="line">    &#x2F;&#x2F; http:&#x2F;&#x2F;vuejs.github.io&#x2F;vue-loader&#x2F;en&#x2F;workflow&#x2F;production.html</span><br><span class="line">    new webpack.DefinePlugin(&#123;</span><br><span class="line">    &#39;process.env&#39;: env</span><br><span class="line">    &#125;),</span><br><span class="line">    &#x2F;&#x2F; 丑化压缩代码</span><br><span class="line">    new UglifyJsPlugin(&#123;</span><br><span class="line">    uglifyOptions: &#123;</span><br><span class="line">        compress: &#123;</span><br><span class="line">        warnings: false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    sourceMap: config.build.productionSourceMap,</span><br><span class="line">    parallel: true</span><br><span class="line">    &#125;),</span><br><span class="line">    &#x2F;&#x2F; 抽离css文件。</span><br><span class="line">    new ExtractTextPlugin(&#123;</span><br><span class="line">    filename: utils.assetsPath(&#39;css&#x2F;[name].[contenthash].css&#39;),</span><br><span class="line">    &#x2F;&#x2F; Setting the following option to &#96;false&#96; will not extract CSS from codesplit chunks.</span><br><span class="line">    &#x2F;&#x2F; Their CSS will instead be inserted dynamically with style-loader when the codesplit chunk has been loaded by webpack.</span><br><span class="line">    &#x2F;&#x2F; It&#39;s currently set to &#96;true&#96; because we are seeing that sourcemaps are included in the codesplit bundle as well when it&#39;s &#96;false&#96;, </span><br><span class="line">    &#x2F;&#x2F; increasing file size: https:&#x2F;&#x2F;github.com&#x2F;vuejs-templates&#x2F;webpack&#x2F;issues&#x2F;1110</span><br><span class="line">    allChunks: true,</span><br><span class="line">    &#125;),</span><br><span class="line">    &#x2F;&#x2F; Compress extracted CSS. We are using this plugin so that possible</span><br><span class="line">    &#x2F;&#x2F; duplicated CSS from different components can be deduped.</span><br><span class="line">    new OptimizeCSSPlugin(&#123;</span><br><span class="line">    cssProcessorOptions: config.build.productionSourceMap</span><br><span class="line">        ? &#123; safe: true, map: &#123; inline: false &#125; &#125;</span><br><span class="line">        : &#123; safe: true &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    &#x2F;&#x2F; generate dist index.html with correct asset hash for caching.</span><br><span class="line">    &#x2F;&#x2F; you can customize output by editing &#x2F;index.html</span><br><span class="line">    &#x2F;&#x2F; see https:&#x2F;&#x2F;github.com&#x2F;ampedandwired&#x2F;html-webpack-plugin</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">    filename: config.build.index,</span><br><span class="line">    template: &#39;index.html&#39;,</span><br><span class="line">    inject: true,</span><br><span class="line">    minify: &#123;</span><br><span class="line">        removeComments: true,</span><br><span class="line">        collapseWhitespace: true,</span><br><span class="line">        removeAttributeQuotes: true</span><br><span class="line">        &#x2F;&#x2F; more options:</span><br><span class="line">        &#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;kangax&#x2F;html-minifier#options-quick-reference</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; necessary to consistently work with multiple chunks via CommonsChunkPlugin</span><br><span class="line">    chunksSortMode: &#39;dependency&#39;</span><br><span class="line">    &#125;),</span><br><span class="line">    &#x2F;&#x2F; keep module.id stable when vendor modules does not change</span><br><span class="line">    new webpack.HashedModuleIdsPlugin(),</span><br><span class="line">    &#x2F;&#x2F; enable scope hoisting</span><br><span class="line">    new webpack.optimize.ModuleConcatenationPlugin(),</span><br><span class="line">    &#x2F;&#x2F; split vendor js into its own file</span><br><span class="line">    new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">    name: &#39;vendor&#39;,</span><br><span class="line">    minChunks (module) &#123;</span><br><span class="line">        &#x2F;&#x2F; any required modules inside node_modules are extracted to vendor</span><br><span class="line">        return (</span><br><span class="line">        module.resource &amp;&amp;</span><br><span class="line">        &#x2F;\.js$&#x2F;.test(module.resource) &amp;&amp;</span><br><span class="line">        module.resource.indexOf(</span><br><span class="line">            path.join(__dirname, &#39;..&#x2F;node_modules&#39;)</span><br><span class="line">        ) &#x3D;&#x3D;&#x3D; 0</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    &#x2F;&#x2F; extract webpack runtime and module manifest to its own file in order to</span><br><span class="line">    &#x2F;&#x2F; prevent vendor hash from being updated whenever app bundle is updated</span><br><span class="line">    new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">    name: &#39;manifest&#39;,</span><br><span class="line">    minChunks: Infinity</span><br><span class="line">    &#125;),</span><br><span class="line">    &#x2F;&#x2F; This instance extracts shared chunks from code splitted chunks and bundles them</span><br><span class="line">    &#x2F;&#x2F; in a separate chunk, similar to the vendor chunk</span><br><span class="line">    &#x2F;&#x2F; see: https:&#x2F;&#x2F;webpack.js.org&#x2F;plugins&#x2F;commons-chunk-plugin&#x2F;#extra-async-commons-chunk</span><br><span class="line">    new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">    name: &#39;app&#39;,</span><br><span class="line">    async: &#39;vendor-async&#39;,</span><br><span class="line">    children: true,</span><br><span class="line">    minChunks: 3</span><br><span class="line">    &#125;),</span><br><span class="line">    &#x2F;&#x2F; copy custom static assets</span><br><span class="line">    new CopyWebpackPlugin([</span><br><span class="line">    &#123;</span><br><span class="line">        from: path.resolve(__dirname, &#39;..&#x2F;static&#39;),</span><br><span class="line">        to: config.build.assetsSubDirectory,</span><br><span class="line">        ignore: [&#39;.*&#39;]</span><br><span class="line">    &#125;</span><br><span class="line">    ])</span><br><span class="line">]</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; gzip模式下需要引入compression插件进行压缩。</span><br><span class="line">if (config.build.productionGzip) &#123;</span><br><span class="line">const CompressionWebpackPlugin &#x3D; require(&#39;compression-webpack-plugin&#39;)</span><br><span class="line">webpackConfig.plugins.push(</span><br><span class="line">    new CompressionWebpackPlugin(&#123;</span><br><span class="line">    asset: &#39;[path].gz[query]&#39;,</span><br><span class="line">    algorithm: &#39;gzip&#39;,</span><br><span class="line">    test: new RegExp(</span><br><span class="line">        &#39;\\.(&#39; +</span><br><span class="line">        config.build.productionGzipExtensions.join(&#39;|&#39;) +</span><br><span class="line">        &#39;)$&#39;</span><br><span class="line">    ),</span><br><span class="line">    threshold: 10240,</span><br><span class="line">    minRatio: 0.8</span><br><span class="line">    &#125;)</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">if (config.build.bundleAnalyzerReport) &#123;</span><br><span class="line">const BundleAnalyzerPlugin &#x3D; require(&#39;webpack-bundle-analyzer&#39;).BundleAnalyzerPlugin</span><br><span class="line">webpackConfig.plugins.push(new BundleAnalyzerPlugin())</span><br><span class="line">&#125;</span><br><span class="line">module.exports &#x3D; webpackConfig</span><br></pre></td></tr></table></figure>
<p><code>build/dev-server.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">检查node和npm的版本、引入相关插件和配置</span><br><span class="line">webpack对源码进行编译打包并返回compiler对象</span><br><span class="line">创建express服务器</span><br><span class="line">配置开发中间件（webpack-dev-middleware）和热重载中间件（webpack-hot-middleware）</span><br><span class="line">挂载代理服务和中间件</span><br><span class="line">配置静态资源</span><br><span class="line">启动服务器监听特定端口（8080）</span><br><span class="line">自动打开浏览器并打开特定网址（localhost:8080）</span><br><span class="line">说明： express服务器提供静态文件服务，不过它还使用了http-proxy-middleware，一个http请求代理的中间件。前端开发过程中需要使用到后台的API的话，可以通过配置proxyTable来将相应的后台请求代理到专用的API服务器。</span><br></pre></td></tr></table></figure>
<p><code>build/dev-client.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dev-client.js里面主要写了浏览器端代码，用于实现webpack的热更新（实现浏览器端的EventSource，用于跟服务器双向通信webpack热重载客户端跟dev-server上的热重载插件之间需要进行双向通信, 服务端webpack重新编译后，会向客户端推送信息，告诉客户端进行更新）。</span><br></pre></td></tr></table></figure>
<h3 id="config文件夹分析"><a class="header-anchor" href="#config文件夹分析">¶</a> config文件夹分析</h3>
<p><code>config/dev.env.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设置了开发环境变量。</span><br></pre></td></tr></table></figure>
<p><code>config/prod.env.j</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设置了生产环境变量。</span><br></pre></td></tr></table></figure>
<p><code>config/index.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//描述了开发和构建两种环境下的配置，前面的build文件夹下也有不少文件引用了index.js里面的配置。</span></span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(‘path‘)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 构建产品时使用的配置</span></span><br><span class="line">  build: &#123;</span><br><span class="line">    <span class="comment">// 环境变量</span></span><br><span class="line">    env: <span class="built_in">require</span>(‘./prod.env‘),</span><br><span class="line">    <span class="comment">// html入口文件</span></span><br><span class="line">    index: path.resolve(__dirname, ‘../dist/index.html‘),</span><br><span class="line">    <span class="comment">// 产品文件的存放路径</span></span><br><span class="line">    assetsRoot: path.resolve(__dirname, ‘../dist‘),</span><br><span class="line">    <span class="comment">// 二级目录，存放静态资源文件的目录，位于dist文件夹下</span></span><br><span class="line">    assetsSubDirectory: ‘<span class="keyword">static</span>‘,</span><br><span class="line">    <span class="comment">// 发布路径，如果构建后的产品文件有用于发布CDN或者放到其他域名的服务器，可以在这里进行设置</span></span><br><span class="line">    <span class="comment">// 设置之后构建的产品文件在注入到index.html中的时候就会带上这里的发布路径</span></span><br><span class="line">    assetsPublicPath: ‘/‘,</span><br><span class="line">    <span class="comment">// 是否使用source-map</span></span><br><span class="line">    productionSourceMap: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// Gzip off by default as many popular static hosts such as</span></span><br><span class="line">    <span class="comment">// Surge or Netlify already gzip all static assets for you.</span></span><br><span class="line">    <span class="comment">// Before setting to `true`, make sure to:</span></span><br><span class="line">    <span class="comment">// npm install --save-dev compression-webpack-plugin</span></span><br><span class="line">    <span class="comment">// 是否开启gzip压缩</span></span><br><span class="line">    productionGzip: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// gzip模式下需要压缩的文件的扩展名，设置js、css之后就只会对js和css文件进行压缩</span></span><br><span class="line">    productionGzipExtensions: [‘js‘, ‘css‘],</span><br><span class="line">    <span class="comment">// Run the build command with an extra argument to</span></span><br><span class="line">    <span class="comment">// View the bundle analyzer report after build finishes:</span></span><br><span class="line">    <span class="comment">// `npm run build --report`</span></span><br><span class="line">    <span class="comment">// Set to `true` or `false` to always turn it on or off</span></span><br><span class="line">    <span class="comment">// 是否展示webpack构建打包之后的分析报告</span></span><br><span class="line">    bundleAnalyzerReport: process.env.npm_config_report</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 开发过程中使用的配置</span></span><br><span class="line">  dev: &#123;</span><br><span class="line">    <span class="comment">// 环境变量</span></span><br><span class="line">    env: <span class="built_in">require</span>(‘./dev.env‘),</span><br><span class="line">    <span class="comment">// dev-server监听的端口</span></span><br><span class="line">    port: <span class="number">8080</span>,</span><br><span class="line">    <span class="comment">// 是否自动打开浏览器</span></span><br><span class="line">    autoOpenBrowser: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 静态资源文件夹</span></span><br><span class="line">    assetsSubDirectory: ‘<span class="keyword">static</span>‘,</span><br><span class="line">    <span class="comment">// 发布路径</span></span><br><span class="line">    assetsPublicPath: ‘/‘,</span><br><span class="line">    <span class="comment">// 代理配置表，在这里可以配置特定的请求代理到对应的API接口</span></span><br><span class="line">    <span class="comment">// 例如将‘localhost:8080/api/xxx‘代理到‘www.example.com/api/xxx‘</span></span><br><span class="line">    proxyTable: &#123;&#125;,</span><br><span class="line">    <span class="comment">// CSS Sourcemaps off by default because relative paths are "buggy"</span></span><br><span class="line">    <span class="comment">// with this option, according to the CSS-Loader README</span></span><br><span class="line">    <span class="comment">// (https://github.com/webpack/css-loader#sourcemaps)</span></span><br><span class="line">    <span class="comment">// In our experience, they generally work as expected,</span></span><br><span class="line">    <span class="comment">// just be aware of this issue when enabling this option.</span></span><br><span class="line">    <span class="comment">// 是否开启 cssSourceMap</span></span><br><span class="line">    cssSourceMap: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css">]]></content>
      <categories>
        <category>VUE技术</category>
      </categories>
      <tags>
        <tag>VUE</tag>
        <tag>IDE</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac环境 STS（spring tool suite）导入lombok</title>
    <url>/57654/</url>
    <content><![CDATA[<h3 id="STS 如何导入Lombok"><a class="header-anchor" href="#STS 如何导入Lombok">¶</a> STS 如何导入Lombok</h3>
<h4 id="MacOS 环境下"><a class="header-anchor" href="#MacOS 环境下">¶</a> MacOS 环境下</h4>
<ol>
<li>安装好的STS 我的是 <code>Spring Tool Suite 4 </code></li>
<li><a href="https://projectlombok.org/download.html" target="_blank" rel="noopener">下载lombok.jar包</a></li>
<li>将<code>lombok.jar</code>放到<code>/Applications/SpringToolSuite4.app/Contents/Eclipse/</code>目录下</li>
<li>执行 <code>java -jar /Applications/SpringToolSuite4.app/Contents/Eclipse/lombok.jar</code>如下图:</li>
</ol>
<p><img src="/images/pasted-1.png" alt="upload successful"></p>
<ol start="5">
<li>点击完<code>install/update</code>按钮后查看文件<code>java -jar /Applications/SpringToolSuite4.app/Contents/Eclipse/SpringToolSuite4.ini</code>是否有如下内容，如果没有则手动加上</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-javaagent:&#x2F;Applications&#x2F;SpringToolSuite4.app&#x2F;Contents&#x2F;Eclipse&#x2F;lombok.jar</span><br><span class="line">-Xbootclasspath&#x2F;a:lombok.jar</span><br><span class="line">-vmargs -javaagent:lombok.jar</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>保存后退出</li>
</ol>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css">]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>STS</tag>
        <tag>lombok</tag>
      </tags>
  </entry>
  <entry>
    <title>structlog4j的介绍</title>
    <url>/37896/</url>
    <content><![CDATA[<h2 id="JAVA结构化日志包"><a class="header-anchor" href="#JAVA结构化日志包">¶</a> JAVA结构化日志包</h2>
<p><img src="https://github.com/jacek99/structlog4j/raw/master/img/logo.png" alt=""></p>
<p><a href="https://github.com/jacek99/structlog4j" target="_blank" rel="noopener">GITHUB地址</a></p>
<h3 id="简介"><a class="header-anchor" href="#简介">¶</a> 简介</h3>
<p>Structlog4J基于SLF4J的API基础之上，设计了生成简而易懂的具有数据结构的日志消息，可以将日志内容提供给一些日志分析的服务，比如说LogStash，Splunk，ElasticSearch，等等。</p>
<h3 id="如何添加到项目中"><a class="header-anchor" href="#如何添加到项目中">¶</a> 如何添加到项目中</h3>
<p>这个工具包的jar包已经提交到比较流行的Bintray JCcenter Maven 仓库中。</p>
<h4 id="Gradle 方式引用"><a class="header-anchor" href="#Gradle 方式引用">¶</a> Gradle 方式引用</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">compile &#39;structlog4j:structlog4j-api:1.0.0&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Optional JSON formatter</span><br><span class="line">compile &#39;structlog4j:structlog4j-json:1.0.0&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Optional YAML formatter</span><br><span class="line">compile &#39;structlog4j:structlog4j-yaml:1.0.0&#39;</span><br></pre></td></tr></table></figure>
<h4 id="Maven"><a class="header-anchor" href="#Maven">¶</a> Maven</h4>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--仓库--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>jcenter<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://jcenter.bintray.com<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>structlog4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>structlog4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Optional JSON formatter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>structlog4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>structlog4j-json<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Optional YAML formatter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>structlog4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>structlog4j-yaml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="预览"><a class="header-anchor" href="#预览">¶</a> 预览</h3>
<p>标准的JAVA日志输出像这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Processed 23 flight records for flight UA1234 for airline United</span><br></pre></td></tr></table></figure>
<p>这个是人类比较容易读懂的，但是对于那些日志分析服务是要解析这些内容的含义是比较麻烦的，因为任何开发人员都可以输入任何他们可以表达预期含义的文字和格式。</p>
<p>解决上述问题，我们利用这个工具包可以生成的消息格式像这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Processed flight records recordCount&#x3D;23 airlineCode&#x3D;UA flightNumber&#x3D;1234 airlineName&#x3D;United</span><br></pre></td></tr></table></figure>
<p>或者是JSON格式（需要使用自带的JSON格式化包）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;message&quot;: &quot;Processed flight records&quot;,</span><br><span class="line">    &quot;recordCount&quot;: 23,</span><br><span class="line">    &quot;airlineCode&quot;: &quot;UA&quot;,</span><br><span class="line">    &quot;flightNumber&quot;: &quot;1234&quot;,</span><br><span class="line">    &quot;airlineName&quot;: &quot;United&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者是YAML格式（需要使用自带的YAML格式化包）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">message: Processed flight records</span><br><span class="line">recordCount: 23</span><br><span class="line">airlineCode: UA</span><br><span class="line">flightNumber: 1234</span><br><span class="line">airlineName: United</span><br></pre></td></tr></table></figure>
<p>这些格式是非常容易被解析的，通过键值对的形式非常简单准确的描述了日志表达的信息。</p>
<p>When this type of log entry is forwarded to a log aggregation service (such as Splunk, Logstash, etc) it is trivial to parse it and extract context information from it.<br>
Thus, it is very easy to perform log analytics, which are criticial to many open applications (especially multi-tenant cloud applications).</p>
<h1 id="Usage"><a class="header-anchor" href="#Usage">¶</a> Usage</h1>
<p>StructLog4J is implemented itself on top of the SLF4J API. Therefore any application that already uses SLF4J can<br>
start using it immediately as it requires no other changes to existing logging configuration.</p>
<p>Instead of the standard SLF4J Logger, you must instantiate the StructLog4J Logger:</p>
<pre><code>private ILogger log = SLoggerFactory.getLogger(MyClass.class);
</code></pre>
<p>The <strong>ILogger</strong> interface is very simple and offers just these basic methods:</p>
<pre><code>public interface ILogger {
    public void error(String message, Object...params);
    public void warn(String message, Object...params);
    public void info(String message, Object...params);
    public void debug(String message, Object...params);
    public void trace(String message, Object...params);
}
</code></pre>
<h2 id="Logging key value pairs"><a class="header-anchor" href="#Logging key value pairs">¶</a> Logging key value pairs</h2>
<p>Just pass in key/value pairs as parameters (all keys <strong>must</strong> be String, values can be anything), e.g.</p>
<pre><code>log.info(&quot;Starting processing&quot;,
            &quot;user&quot;, securityContext.getPrincipal().getName(),
            &quot;tenanId&quot;,securityContext.getTenantId());
</code></pre>
<p>which would generate a log message like:</p>
<pre><code>Starting processing user=johndoe@gmail.com tenantId=SOME_TENANT_ID
</code></pre>
<h2 id="Logging exceptions"><a class="header-anchor" href="#Logging exceptions">¶</a> Logging exceptions</h2>
<p>There is no separate API for Throwable (like in SLF4j), just pass in the exception as one of the parameters (order is not<br>
important) and we will log its root cause message and the entire exception stack trace:</p>
<pre><code>} catch (Exception e) {
    log.error(&quot;Error occcurred during batch processing&quot;,
        &quot;user&quot;,securityContext.getPrincipal().getName(),
        &quot;tenanId&quot;,securityContext.getTenantId(),
        e);
}
</code></pre>
<p>which would generate a log message like:</p>
<pre><code>Error occurred during batch processing user=johndoe@gmail.com tenantId=SOME_TENANT_ID errorMessage=&quot;ORA-14094: Oracle Hates You&quot;
...followed by regular full stack trace of the exception...
</code></pre>
<h2 id="Enforcing custom logging format per object"><a class="header-anchor" href="#Enforcing custom logging format per object">¶</a> Enforcing custom logging format per object</h2>
<p>If you wish, any POJO in your app can implement the <strong>IToLog</strong> interface, e.g.</p>
<pre><code>public class TenantSecurityContext implements IToLog {

    private String userName;
    private String tenantId;

    @Override
    public Object[] toLog() {
        return new Object[]{&quot;userName&quot;,getUserName(),&quot;tenantId&quot;,getTenantId()};
    }
}
</code></pre>
<p>Then you can just pass in the object instance directly, without the need to specify any key/value pairs:</p>
<pre><code>log.info(&quot;Starting processing&quot;,securityContext);
</code></pre>
<p>and that will generate a log entry like:</p>
<pre><code>Starting processing user=johndoe@gmail.com tenantId=SOME_TENANT_ID
</code></pre>
<h2 id="All together now"><a class="header-anchor" href="#All together now">¶</a> All together now</h2>
<p>You can mix and match all of these together without any issues:</p>
<pre><code>    } catch (Exception e) {
        log.error(&quot;Error occcurred during batch processing&quot;,
            securityContext,
            e,
            &quot;hostname&quot;, InetAddress.getLocalHost().getHostName());
    }
</code></pre>
<p>and you would get:</p>
<pre><code>Error occurred during batch processing user=johndoe@gmail.com tenantId=SOME_TENANT_ID errorMessage=&quot;ORA-14094: Oracle Hates You&quot; hostname=DEV_SERVER1
...followed by regular full stack trace of the exception...
</code></pre>
<h2 id="Specifying mandatory context key/value pairs"><a class="header-anchor" href="#Specifying mandatory context key/value pairs">¶</a> Specifying mandatory context key/value pairs</h2>
<p>If you have specific key/value pairs that you would like logged automatically with every log entry (host name and service name are a good example),<br>
then you just have to specify a mandatory context lambda:</p>
<pre><code>StructLog4J.setMandatoryContextSupplier(() -&gt; new Object[]{
    &quot;hostname&quot;, InetAddress.getLocalHost().getHostName(),
    &quot;serviceName&quot;,&quot;MyService&quot;});
</code></pre>
<p>Now these mandatory key/value pairs will be logged automatically on <strong>every</strong> log entry, without the need to specify them manually.</p>
<h1 id="Logging Formats"><a class="header-anchor" href="#Logging Formats">¶</a> Logging Formats</h1>
<h2 id="Key/Value Pairs"><a class="header-anchor" href="#Key/Value Pairs">¶</a> Key/Value Pairs</h2>
<p>By default we log in the standard key/value pair format, e.g.:</p>
<pre><code>Starting processing user=johndoe@gmail.com tenantId=SOME_TENANT_ID
</code></pre>
<p>No extra configuration is necesary.</p>
<h2 id="JSON"><a class="header-anchor" href="#JSON">¶</a> JSON</h2>
<p>If you want all messages to be logged in JSON instead, e.g.</p>
<pre><code>    {
        &quot;message&quot;: &quot;Started processing&quot;,
        &quot;user&quot;: johndoe@gmail.com,
        &quot;tenantId&quot;: &quot;SOME_TENANT_ID&quot;
    }
</code></pre>
<p>then you need to add the JSON formatter library as a dependency (where $version is the current library version):</p>
<pre><code>compile 'structlog4j:structlog4j-json:$version'
</code></pre>
<p>and then just execute the following code in the startup main() of your application:</p>
<pre><code>import com.github.structlog4j.json.JsonFormatter;

StructLog4J.setFormatter(JsonFormatter.getInstance());
</code></pre>
<p>That’s it.</p>
<h2 id="YAML"><a class="header-anchor" href="#YAML">¶</a> YAML</h2>
<p>If you want all messages to be logged in YAML instead, e.g.</p>
<pre><code>message: Started processing
user: johndoe@gmail.com
tenantId: SOME_TENANT_ID
</code></pre>
<p>then you need to add the YAML formatter library as a dependency (where $version is the current library version):</p>
<pre><code>compile 'structlog4j:structlog4j-yaml:$version'
</code></pre>
<p>and then just execute the following code in the startup main() of your application:</p>
<pre><code>import com.github.structlog4j.yaml.YamlFormatter;

StructLog4J.setFormatter(YamlFormatter.getInstance());
</code></pre>
<p>That’s it.</p>
<h1 id="License"><a class="header-anchor" href="#License">¶</a> License</h1>
<p>MIT License.</p>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css">]]></content>
      <categories>
        <category>JAVA工具包</category>
      </categories>
      <tags>
        <tag>structlog4j</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言笔记</title>
    <url>/16107/</url>
    <content><![CDATA[<p>这是我在2018年低记得笔记，放在这里记录一下。</p>
<h1 id="GO语言的安装"><a class="header-anchor" href="#GO语言的安装">¶</a> GO语言的安装</h1>
<p>今天学习GO语言的动力是想参与到https://github.com/fatedier/frp 这个项目中来<br>
参考资料:</p>
<ol>
<li>安装包下载：<a href="http://www.golangtc.com/download" target="_blank" rel="noopener">http://www.golangtc.com/download</a></li>
<li>GO的安装：<a href="http://docscn.studygolang.com/doc/install" target="_blank" rel="noopener">http://docscn.studygolang.com/doc/install</a></li>
<li>搭建Go开发及调试环境（LiteIDE + GoClipse） – Windows篇：<a href="http://www.cnblogs.com/custa/p/3913526.html" target="_blank" rel="noopener">http://www.cnblogs.com/custa/p/3913526.html</a></li>
<li>GO语言指南:<a href="https://tour.go-zh.org/list" target="_blank" rel="noopener">https://tour.go-zh.org/list</a></li>
<li>GO语言文档:<a href="http://docscn.studygolang.com/doc/" target="_blank" rel="noopener">http://docscn.studygolang.com/doc/</a></li>
<li>GO语言教程:<a href="http://www.runoob.com/w3cnote/wx-xcx-repo.html" target="_blank" rel="noopener">http://www.runoob.com/w3cnote/wx-xcx-repo.html</a></li>
</ol>
<h2 id="安装描述： Windows 系统下安装"><a class="header-anchor" href="#安装描述： Windows 系统下安装">¶</a> 安装描述： Windows 系统下安装</h2>
<p>Windows 下可以使用 .msi后缀(在下载列表中可以找到该文件，如:go1.7.3.windows-amd64.msi)的安装包来安装。<br>
默认情况下.msi文件会安装在 c:\Go 目录下。你可以将 c:\Go\bin 目录添加到 PATH 环境变量中。添加后你需要重启命令窗口才能生效</p>
<blockquote>
<p>设置GOROOT变量与GO安装路径一致。</p>
</blockquote>
<h2 id="安装测试"><a class="header-anchor" href="#安装测试">¶</a> 安装测试</h2>
<ol>
<li>创建工作目录 C:\&gt;Go_WorkSpace。</li>
<li>文件名: test.go，代码如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   fmt.Println(&quot;Hello, World!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>使用 go 命令执行以上代码输出结果如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Go_WorkSpace&gt;go run test.go</span><br><span class="line"></span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure>
<h1 id="GO的语言结构"><a class="header-anchor" href="#GO的语言结构">¶</a> GO的语言结构</h1>
<pre><code>Go 语言最简单程序的结构
</code></pre>
<ul>
<li>包声明</li>
<li>引入包</li>
<li>函数</li>
<li>变量</li>
<li>语句 &amp; 表达式</li>
<li>注释</li>
</ul>
<p>下面来看一段程序代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;第一行代码 package main 定义了包名。你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。</span><br><span class="line">&#x2F;&#x2F;package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。</span><br><span class="line">package main</span><br><span class="line">&#x2F;&#x2F;下一行 import &quot;fmt&quot; 告诉 Go 编译器这个程序需要使用 fmt 包（的函数，或其他元素），fmt 包实现了格式化 IO（输入&#x2F;输出）的函数。</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">&#x2F;&#x2F;下一行 func main() 是程序开始执行的函数。main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数）。</span><br><span class="line">func main() &#123;</span><br><span class="line">   &#x2F;&#x2F;这是一个单行注释</span><br><span class="line">   &#x2F;* 多行注释 这是我的第一个简单的程序 *&#x2F;</span><br><span class="line">   &#x2F;&#x2F;下一行 fmt.Println(...) 可以将字符串输出到控制台，并在最后自动增加换行字符 \n。 </span><br><span class="line">   &#x2F;&#x2F;使用 fmt.Print(&quot;hello, world\n&quot;) 可以得到相同的结果。 </span><br><span class="line">   &#x2F;&#x2F;Print 和 Println 这两个函数也支持使用变量，如：fmt.Println(arr)。如果没有特别指定，它们会以默认的打印格式将变量 arr 输出到控制台。</span><br><span class="line">   fmt.Println(&quot;Hello, World!&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* 语言特点:</span><br><span class="line">当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 private ）。</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>
<h2 id="执行 Go 程序"><a class="header-anchor" href="#执行 Go 程序">¶</a> 执行 Go 程序</h2>
<ul>
<li>打开编辑器如Sublime2，将以上代码添加到编辑器中。</li>
<li>将以上代码保存为 hello.go</li>
<li>打开命令行，并进入程序文件保存的目录中。</li>
<li>输入命令 go run hello.go 并按回车执行代码。</li>
<li>如果操作正确你将在屏幕上看到 “Hello World!” 字样的输出。</li>
</ul>
<h1 id="GO语言的基础语法"><a class="header-anchor" href="#GO语言的基础语法">¶</a> GO语言的基础语法</h1>
<h2 id="Go 标记"><a class="header-anchor" href="#Go 标记">¶</a> Go 标记</h2>
<p>Go 程序可以由多个标记组成，可以是关键字，标识符，常量，字符串，符号。如以下 GO 语句由 6 个标记组成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fmt.Println(&quot;Hello, World!&quot;)</span><br></pre></td></tr></table></figure>
<p>6个标记是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. fmt</span><br><span class="line">2. .</span><br><span class="line">3. Println</span><br><span class="line">4. (</span><br><span class="line">5. &quot;Hello, World!&quot;</span><br><span class="line">6. )</span><br></pre></td></tr></table></figure>
<h2 id="行分隔符"><a class="header-anchor" href="#行分隔符">¶</a> 行分隔符</h2>
<p>在 Go 程序中，一行代表一个语句结束。每个语句不需要像 C 家族中的其它语言一样以分号 ; 结尾，因为这些工作都将由 Go 编译器自动完成。<br>
如果你打算将多个语句写在同一行，它们则必须使用 ; 人为区分，但在实际开发中我们并不鼓励这种做法。<br>
以下为两个语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fmt.Println(&quot;Hello, World!&quot;)</span><br><span class="line">fmt.Println(&quot;GO教程：blog.ledanzu.com&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="注释"><a class="header-anchor" href="#注释">¶</a> 注释</h2>
<p>注释不会被编译，每一个包应该有相关注释。<br>
单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释。多行注释也叫块注释，均已以 /* 开头，并以 */ 结尾。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 单行注释</span><br><span class="line">&#x2F;*</span><br><span class="line"> Author by arlin.wang</span><br><span class="line"> 我是多行注释</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>
<h2 id="标识符"><a class="header-anchor" href="#标识符">¶</a> 标识符</h2>
<p>标识符用来命名变量、类型等程序实体。一个标识符实际上就是一个或是多个字母(A<sub>Z和a</sub>z)数字(0~9)、下划线_组成的序列，但是第一个字符必须是字母或下划线而不能是数字。<br>
以下是有效的标识符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mahesh   kumar   abc   move_name   a_123</span><br><span class="line">myname50   _temp   j   a23b9   retVal</span><br></pre></td></tr></table></figure>
<p>以下是无效的标识符：</p>
<ul>
<li>1ab（以数字开头）</li>
<li>case（Go 语言的关键字）</li>
<li>a+b（运算符是不允许的）</li>
</ul>
<h2 id="关键字"><a class="header-anchor" href="#关键字">¶</a> 关键字</h2>
<p>下面列举了 Go 代码中会使用到的 25 个关键字或保留字：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>名称</th>
<th>描述</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>break</td>
<td>跳出</td>
<td>default</td>
<td>默认</td>
<td>func</td>
<td>函数</td>
</tr>
<tr>
<td>interface</td>
<td>接口</td>
<td>select</td>
<td></td>
<td>case</td>
<td>比较</td>
</tr>
<tr>
<td>defer</td>
<td></td>
<td>go</td>
<td></td>
<td>map</td>
<td>键值对</td>
</tr>
<tr>
<td>struct</td>
<td></td>
<td>chan</td>
<td></td>
<td>else</td>
<td>否则</td>
</tr>
<tr>
<td>goto</td>
<td>跳转</td>
<td>package</td>
<td>包定义</td>
<td>switch</td>
<td>开关</td>
</tr>
<tr>
<td>const</td>
<td>常量</td>
<td>fallthrough</td>
<td></td>
<td>if</td>
<td>如果</td>
</tr>
<tr>
<td>range</td>
<td></td>
<td>type</td>
<td>类型</td>
<td>continue</td>
<td>继续</td>
</tr>
<tr>
<td>for</td>
<td>O(∩_∩)O</td>
<td>import</td>
<td>引入</td>
<td>return</td>
<td>返回</td>
</tr>
<tr>
<td>var</td>
<td>变量</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>除了以上介绍的这些关键字，Go 语言还有 36 个预定义标识符：</p>
<table>
<thead>
<tr>
<th>append</th>
<th>bool</th>
<th>byte</th>
<th>cap</th>
<th>close</th>
<th>complex</th>
<th>complex64</th>
<th>complex128</th>
<th>uint16</th>
</tr>
</thead>
<tbody>
<tr>
<td>copy</td>
<td>false</td>
<td>float32</td>
<td>float64</td>
<td>imag</td>
<td>int</td>
<td>int8</td>
<td>int16</td>
<td>uint32</td>
</tr>
<tr>
<td>int32</td>
<td>int64</td>
<td>iota</td>
<td>len</td>
<td>make</td>
<td>new</td>
<td>nil</td>
<td>panic</td>
<td>uint64</td>
</tr>
<tr>
<td>print</td>
<td>println</td>
<td>real</td>
<td>recover</td>
<td>string</td>
<td>true</td>
<td>uint</td>
<td>uint8</td>
<td>uintptr</td>
</tr>
</tbody>
</table>
<p>程序一般由关键字、常量、变量、运算符、类型和函数组成。<br>
程序中可能会使用到这些分隔符：括号 ()，中括号 [] 和大括号 {}。<br>
程序中可能会使用到这些标点符号：.、,、;、: 和 …。</p>
<h2 id="Go 语言的空格"><a class="header-anchor" href="#Go 语言的空格">¶</a> Go 语言的空格</h2>
<p>Go 语言中变量的声明必须使用空格隔开，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var age int;</span><br></pre></td></tr></table></figure>
<p>语句中适当使用空格能让程序看易阅读。<br>
无空格：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fruit&#x3D;apples+oranges;</span><br></pre></td></tr></table></figure>
<p>在变量与运算符间加入空格，程序看起来更加美观，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fruit &#x3D; apples + oranges;</span><br></pre></td></tr></table></figure>
<h1 id="Go 语言数据类型"><a class="header-anchor" href="#Go 语言数据类型">¶</a> Go 语言数据类型</h1>
<p>在 Go 编程语言中，数据类型用于声明函数和变量。<br>
数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候才需要申请大内存，就可以充分利用内存。<br>
Go 语言按类别有以下几种数据类型：</p>
<h2 id="布尔类型 bool"><a class="header-anchor" href="#布尔类型 bool">¶</a> 布尔类型 bool</h2>
<p>布尔型的值只可以是常量 true 或者 false。一个简单的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var b bool &#x3D; true</span><br></pre></td></tr></table></figure>
<h2 id="数字类型"><a class="header-anchor" href="#数字类型">¶</a> 数字类型</h2>
<p>整型 int 和浮点型 float，Go 语言支持整型和浮点型数字，并且原生支持复数，其中位的运算采用补码。</p>
<p>Go 也有基于架构的类型，例如：int、uint 和 uintptr。</p>
<h3 id="整型:"><a class="header-anchor" href="#整型:">¶</a> 整型:</h3>
<h5 id="uint8"><a class="header-anchor" href="#uint8">¶</a> uint8</h5>
<p>无符号 8 位整型 (0 到 255)</p>
<h5 id="uint16"><a class="header-anchor" href="#uint16">¶</a> uint16</h5>
<p>无符号 16 位整型 (0 到 65535)</p>
<h5 id="uint32"><a class="header-anchor" href="#uint32">¶</a> uint32</h5>
<p>无符号 32 位整型 (0 到 4294967295)</p>
<h5 id="uint64"><a class="header-anchor" href="#uint64">¶</a> uint64</h5>
<p>无符号 64 位整型 (0 到 18446744073709551615)</p>
<h5 id="int8"><a class="header-anchor" href="#int8">¶</a> int8</h5>
<p>有符号 8 位整型 (-128 到 127)</p>
<h5 id="int16"><a class="header-anchor" href="#int16">¶</a> int16</h5>
<p>有符号 16 位整型 (-32768 到 32767)</p>
<h5 id="int32"><a class="header-anchor" href="#int32">¶</a> int32</h5>
<p>有符号 32 位整型 (-2147483648 到 2147483647)</p>
<h5 id="int64"><a class="header-anchor" href="#int64">¶</a> int64</h5>
<p>有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)</p>
<h3 id="浮点型："><a class="header-anchor" href="#浮点型：">¶</a> 浮点型：</h3>
<h5 id="float32"><a class="header-anchor" href="#float32">¶</a> float32</h5>
<p>IEEE-754 32位浮点型数</p>
<h5 id="float64"><a class="header-anchor" href="#float64">¶</a> float64</h5>
<p>IEEE-754 64位浮点型数</p>
<h5 id="complex64"><a class="header-anchor" href="#complex64">¶</a> complex64</h5>
<p>32 位实数和虚数</p>
<h5 id="complex128"><a class="header-anchor" href="#complex128">¶</a> complex128</h5>
<p>64 位实数和虚数</p>
<h3 id="其他数字类型："><a class="header-anchor" href="#其他数字类型：">¶</a> 其他数字类型：</h3>
<h5 id="byte"><a class="header-anchor" href="#byte">¶</a> byte</h5>
<p>类似 uint8</p>
<h5 id="rune"><a class="header-anchor" href="#rune">¶</a> rune</h5>
<p>类似 int32</p>
<h5 id="uint"><a class="header-anchor" href="#uint">¶</a> uint</h5>
<p>32 或 64 位</p>
<h5 id="int"><a class="header-anchor" href="#int">¶</a> int</h5>
<p>与 uint 一样大小</p>
<h5 id="uintptr"><a class="header-anchor" href="#uintptr">¶</a> uintptr</h5>
<p>无符号整型，用于存放一个指针</p>
<h1 id="GO语言变量"><a class="header-anchor" href="#GO语言变量">¶</a> GO语言变量</h1>
<p>变量来源于数学，是计算机语言中能储存计算结果或能表示值抽象概念。变量可以通过变量名访问。<br>
Go 语言变量名由字母、数字、下划线组成，其中首个字母不能为数字。<br>
声明变量的一般形式是使用 var 关键字：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var identifier type</span><br><span class="line">&#x2F;&#x2F;例如</span><br><span class="line">var a int</span><br></pre></td></tr></table></figure>
<h3 id="变量声明"><a class="header-anchor" href="#变量声明">¶</a> 变量声明</h3>
<ol>
<li>指定变量类型，声明后没有赋值则使用默认值；</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var v_name v_type</span><br><span class="line">v_name &#x3D; value</span><br><span class="line">&#x2F;&#x2F;例如</span><br><span class="line">var a int</span><br><span class="line">a &#x3D; 10</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>根据值自行判断变量类型；也就是弱类型声明。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var v_name &#x3D; value</span><br><span class="line">&#x2F;&#x2F;例如</span><br><span class="line">var int &#x3D; 10</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>省略var，注意:=左侧的变量不应该是已经声明过的，否则会导致编译错误。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">v_name :&#x3D; value</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 例如</span><br><span class="line">var a int &#x3D; 10</span><br><span class="line">var b &#x3D; 10</span><br><span class="line">c : &#x3D; 10</span><br></pre></td></tr></table></figure>
<p>示例如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">var a &#x3D; &quot;arlin 是个好人&quot;</span><br><span class="line">var b string &#x3D; &quot;arlin.wang&quot;</span><br><span class="line">var c bool</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">    println(a,b,c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arlin 是个好人 arlin.wang false</span><br></pre></td></tr></table></figure>
<blockquote>
<p><mark>注意：由于有中文，采用记事本编辑默认是ANSI码上一段代码报错</mark></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># command-line-arguments</span><br><span class="line">.\indentifier_type.go:3: illegal UTF-8 sequence</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我的解决办法是用notpadd++编辑，报错格式为UTF-8</p>
</blockquote>
<h3 id="多变量声明"><a class="header-anchor" href="#多变量声明">¶</a> 多变量声明</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;类型相同多个变量, 非全局变量</span><br><span class="line">var vname1, vname2, vname3 type</span><br><span class="line">vname1, vname2, vname3 &#x3D; v1, v2, v3</span><br><span class="line"></span><br><span class="line">var vname1, vname2, vname3 &#x3D; v1, v2, v3 &#x2F;&#x2F;和python很像,不需要显示声明类型，自动推断</span><br><span class="line"></span><br><span class="line">vname1, vname2, vname3 :&#x3D; v1, v2, v3 &#x2F;&#x2F;出现在:&#x3D;左侧的变量不应该是已经被声明过的，否则会导致编译错误</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这种因式分解关键字的写法一般用于声明全局变量</span><br><span class="line">var (</span><br><span class="line">    vname1 v_type1</span><br><span class="line">    vname2 v_type2</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>实例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">var x,y int </span><br><span class="line">var ( &#x2F;&#x2F;主意是括号()而不是大括号&#123;&#125;</span><br><span class="line">  a int</span><br><span class="line">  b bool</span><br><span class="line">)</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">var c,d int &#x3D; 1,2</span><br><span class="line">var e,f &#x3D; 123,&quot;arlin&quot;</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">    &#x2F;&#x2F;这种不带声明格式的只能在函数体中出现</span><br><span class="line">    g,h :&#x3D;123,&quot;arlin&quot;</span><br><span class="line">    println(x,y,a,b,c,d,e,f,g,h)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 0 0 false 1 2 123 arlin 123 arlin</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：var ( a int b bool) 是() 而不是{}</p>
</blockquote>
<h3 id="值类型和引用类型"><a class="header-anchor" href="#值类型和引用类型">¶</a> 值类型和引用类型</h3>
<p>所有像 int、float、bool 和 string 这些基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line"> 整形i --&gt;7</span><br></pre></td></tr></table></figure>
<p>当使用等号 = 将一个变量的值赋值给另一个变量时，如：j = i，实际上是在内存中将 i 的值进行了拷贝：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">整形i--&gt;7</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">整形j--&gt;7</span><br></pre></td></tr></table></figure>
<p>你可以通过 &amp;i 来获取变量 i 的内存地址，例如：0xf840000040（每次的地址都可能不一样）。值类型的变量的值存储在栈中。</p>
<p>内存地址会根据机器的不同而有所不同，甚至相同的程序在不同的机器上执行后也会有不同的内存地址。因为每台机器可能有不同的存储器布局，并且位置分配也可能不同。</p>
<p>更复杂的数据通常会需要使用多个字，这些数据一般使用引用类型保存。</p>
<p>一个引用类型的变量 r1 存储的是 r1 的值所在的内存地址（数字），或内存地址中第一个字所在的位置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">ref引用r1 --&gt; 内存地址1</span><br><span class="line">ref引用r2 --&gt; 内存地址1</span><br><span class="line">内存地址1--&gt; r1的值</span><br></pre></td></tr></table></figure>
<p>这个内存地址为称之为指针，这个指针实际上也被存在另外的某一个字中。</p>
<p>同一个引用类型的指针指向的多个字可以是在连续的内存地址中（内存布局是连续的），这也是计算效率最高的一种存储形式；也可以将这些字分散存放在内存中，每个字都指示了下一个字所在的内存地址。</p>
<p>当使用赋值语句 r2 = r1 时，只有引用（地址）被复制。<br>
如果 r1 的值被改变了，那么这个值的所有引用都会指向被修改后的内容，在这个例子中，r2 也会受到影响。</p>
<hr>
<h3 id="简短形式，使用:=赋值操作符"><a class="header-anchor" href="#简短形式，使用:=赋值操作符">¶</a> 简短形式，使用:=赋值操作符</h3>
<p>我们知道可以在变量的初始化时省略变量的类型而由系统自动推断，声明语句写上 var 关键字其实是显得有些多余了，因此我们可以将它们简写为 a := 50 或 b := false。</p>
<p>a 和 b 的类型（int 和 bool）将由编译器自动推断。<br>
这是使用变量的首选形式，但是它只能被用在函数体内，而不可以用于全局变量的声明与赋值。使用操作符 := 可以高效地创建一个新的变量，称之为初始化声明。</p>
<h5 id="注意事项"><a class="header-anchor" href="#注意事项">¶</a> 注意事项</h5>
<p>如果在相同的代码块中，我们不可以再次对于相同名称的变量使用初始化声明，例如：a := 20 就是不被允许的，编译器会提示错误 no new variables on left side of :=，但是 a = 20 是可以的，因为这是给相同的变量赋予一个新的值。<br>
如果你在定义变量 a 之前使用它，则会得到编译错误 undefined: a。</p>
<p>如果你声明了一个局部变量却没有在相同的代码块中使用它，同样会得到编译错误，例如下面这个例子当中的变量 a：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">   var a string &#x3D; &quot;abc&quot;</span><br><span class="line">   fmt.Println(&quot;hello, world&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尝试编译这段代码将得到错误 a declared and not used。<br>
此外，单纯地给 a 赋值也是不够的，这个值必须被使用，所以使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">   var a string &#x3D; &quot;abc&quot;</span><br><span class="line">   fmt.Println(&quot;hello, world&quot;,a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是全局变量是允许声明后不使用的。</p>
<p>同一类型的多个变量可以在同一行声明和赋值如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a , b, c int &#x3D; 1,2,3</span><br></pre></td></tr></table></figure>
<p>多变量可以在同一行进行赋值,如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b ,c ,d &#x3D; 5,7,&quot;abc&quot;</span><br></pre></td></tr></table></figure>
<p>上面这行假设了变量 b，c 和 d 都已经被声明，否则的话应该这样使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b, c ,d:&#x3D; 5, 7, &quot;abc&quot;</span><br></pre></td></tr></table></figure>
<p>这被称为 并行 或 同时 赋值。</p>
<p>如果你想要交换两个变量的值，则可以简单地使用 a, b = b, a。</p>
<p><strong>空白标识符 _ 也被用于抛弃值，如值 5 在：_, b = 5, 7 中被抛弃。</strong></p>
<p>_ 实际上是一个只写变量，你不能得到它的值。这样做是因为 Go 语言中你必须使用所有被声明的变量，但有时你并不需要使用从一个函数得到的所有返回值。</p>
<p><strong>并行赋值也被用于当一个函数返回多个返回值时，比如这里的 val 和错误 err 是通过调用 Func1 函数同时得到：val, err = Func1(var1)。</strong></p>
<h1 id="Go语言常量"><a class="header-anchor" href="#Go语言常量">¶</a> Go语言常量</h1>
<p>常量是一个简单值的标识符，在程序运行时，不会被修改的量。</p>
<p>常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。</p>
<p>常量的定义格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const identifier [type] &#x3D; value</span><br></pre></td></tr></table></figure>
<p>你可以省略类型说明符 [type]，因为编译器可以根据变量的值来推断其类型。</p>
<ul>
<li>显式类型定义： const b string = “abc”</li>
<li>隐式类型定义： const b = “abc”</li>
</ul>
<p>多个相同类型的声明可以简写为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const c_name1, c_name2 &#x3D; value1, value2</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">    const LENGTH int &#x3D; 10</span><br><span class="line">    const WIDTH int &#x3D; 5</span><br><span class="line">    var area int </span><br><span class="line">    const a,b,c &#x3D; 1,false,&quot;str&quot;</span><br><span class="line">    area &#x3D; LENGTH * WIDTH</span><br><span class="line">    fmt.Printf(&quot;面积为 : %d&quot;,area)&#x2F;&#x2F;格式化输出</span><br><span class="line">    println()&#x2F;&#x2F;换行等同于\n  可以省略fmt.</span><br><span class="line">    fmt.Println(a,b,c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">面积为 : 50</span><br><span class="line">1 false str</span><br></pre></td></tr></table></figure>
<p>常量还可以用作枚举:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;数字 0、1 和 2 分别代表未知性别、女性和男性。</span><br><span class="line">const (</span><br><span class="line">    Unknown &#x3D; 0</span><br><span class="line">    Female &#x3D; 1</span><br><span class="line">    Male &#x3D; 2</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>常量可以用len(), cap(), unsafe.Sizeof()常量计算表达式的值。常量表达式中，函数必须是内置函数，否则编译不过：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;unsafe&quot;</span><br><span class="line">const (</span><br><span class="line">    a &#x3D; &quot;abc&quot;</span><br><span class="line">    b &#x3D; len(a)</span><br><span class="line">    &#x2F;&#x2F;查看变量所占字节数。</span><br><span class="line">    c &#x3D; unsafe.Sizeof(a)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">    println(a, b, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abc 3 16</span><br></pre></td></tr></table></figure>
<blockquote>
<p>unsafe 库让 golang 可以像 C 语言一样操作计算机内存，但这并不是 golang 推荐使用的，能不用尽量不用，就像它的名字所表达的一样，它绕过了golang的内存安全原则，是不安全的，容易使你的程序出现莫名其妙的问题，不利于程序的扩展与维护。</p>
</blockquote>
<h3 id="iota 常量"><a class="header-anchor" href="#iota 常量">¶</a> iota 常量</h3>
<p>iota，特殊常量，可以认为是一个可以被编译器修改的常量。</p>
<p>在每一个const关键字出现时，被重置为0，然后再下一个const出现之前，每出现一次iota，其所代表的数字会自动增加1。<br>
iota 可以被用作枚举值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const (</span><br><span class="line">    a &#x3D; iota</span><br><span class="line">    b &#x3D; iota</span><br><span class="line">    c &#x3D; iota</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>第一个 iota 等于 0，每当 iota 在新的一行被使用时，它的值都会自动加 1；所以 a=0, b=1, c=2 可以简写为如下形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const (</span><br><span class="line">    a &#x3D; iota</span><br><span class="line">    b</span><br><span class="line">    c</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h5 id="iota用法"><a class="header-anchor" href="#iota用法">¶</a> iota用法</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">	const (</span><br><span class="line">		a &#x3D; iota &#x2F;&#x2F;0</span><br><span class="line">		b        &#x2F;&#x2F;1</span><br><span class="line">		c        &#x2F;&#x2F;2</span><br><span class="line">		d &#x3D; &quot;ha&quot; &#x2F;&#x2F;独立值,iota +&#x3D;1</span><br><span class="line">		e        &#x2F;&#x2F;&quot;ha&quot;  ,iota +&#x3D;1</span><br><span class="line">		f &#x3D; 100  &#x2F;&#x2F;100   ,iota +&#x3D;1</span><br><span class="line">		g        &#x2F;&#x2F;100   ,iota +&#x3D;1</span><br><span class="line">		h &#x3D; iota &#x2F;&#x2F;7,恢复计数</span><br><span class="line">		i        &#x2F;&#x2F;8</span><br><span class="line">	)</span><br><span class="line">	fmt.Println(a,b,c,d,e,f,g,h,i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 1 2 ha ha 100 100 7 8</span><br></pre></td></tr></table></figure>
<p>实例二：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">	i&#x3D;1&lt;&lt;iota</span><br><span class="line">	j&#x3D;3&lt;&lt;iota</span><br><span class="line">	k</span><br><span class="line">	l</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">	fmt.Println(&quot;i&#x3D;&quot;,i)</span><br><span class="line">	fmt.Println(&quot;j&#x3D;&quot;,j)</span><br><span class="line">	fmt.Println(&quot;k&#x3D;&quot;,k)</span><br><span class="line">	fmt.Println(&quot;l&#x3D;&quot;,l)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i&#x3D; 1</span><br><span class="line">j&#x3D; 6</span><br><span class="line">k&#x3D; 12</span><br><span class="line">l&#x3D; 24</span><br></pre></td></tr></table></figure>
<blockquote>
<p>iota表示从0开始自动加1，所以i=1&lt;&lt;0,j=3&lt;&lt;1（&lt;&lt;表示左移的意思），即：i=1,j=6，这没问题，关键在k和l，从输出结果看，k=3&lt;&lt;2，l=3&lt;&lt; 3。</p>
</blockquote>
<h1 id="GO语言运算符"><a class="header-anchor" href="#GO语言运算符">¶</a> GO语言运算符</h1>
<p>运算符用于在程序运行时执行数学或逻辑运算，有：</p>
<ul>
<li>算术运算符</li>
<li>关系运算符</li>
<li>逻辑运算符</li>
<li>位运算符</li>
<li>赋值运算符</li>
<li>其他运算符</li>
</ul>
<h3 id="算术运算符"><a class="header-anchor" href="#算术运算符">¶</a> 算术运算符</h3>
<p>下表列出了所有Go语言的算术运算符。假定 A 值为 10，B 值为 20。</p>
<table>
<thead>
<tr>
<th>运算符号</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>相加</td>
<td>A + B 输出结果 30</td>
</tr>
<tr>
<td>-</td>
<td>相减</td>
<td>A - B 输出结果 -10</td>
</tr>
<tr>
<td>*</td>
<td>相乘</td>
<td>A * B 输出结果 200</td>
</tr>
<tr>
<td>/</td>
<td>相除</td>
<td>B / A 输出结果 2</td>
</tr>
<tr>
<td>%</td>
<td>求余</td>
<td>B % A 输出结果 0</td>
</tr>
<tr>
<td>++</td>
<td>自增</td>
<td>A++ 输出结果 11</td>
</tr>
<tr>
<td>–</td>
<td>自减</td>
<td>A-- 输出结果 9</td>
</tr>
</tbody>
</table>
<p>以下实例演示了各个算术运算符的用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">   var a int &#x3D; 21</span><br><span class="line">   var b int &#x3D; 10</span><br><span class="line">   var c int</span><br><span class="line"></span><br><span class="line">   c &#x3D; a + b</span><br><span class="line">   fmt.Printf(&quot;第一行 - c 的值为 %d\n&quot;, c )</span><br><span class="line">   c &#x3D; a - b</span><br><span class="line">   fmt.Printf(&quot;第二行 - c 的值为 %d\n&quot;, c )</span><br><span class="line">   c &#x3D; a * b</span><br><span class="line">   fmt.Printf(&quot;第三行 - c 的值为 %d\n&quot;, c )</span><br><span class="line">   c &#x3D; a &#x2F; b</span><br><span class="line">   fmt.Printf(&quot;第四行 - c 的值为 %d\n&quot;, c )</span><br><span class="line">   c &#x3D; a % b</span><br><span class="line">   fmt.Printf(&quot;第五行 - c 的值为 %d\n&quot;, c )</span><br><span class="line">   a++</span><br><span class="line">   fmt.Printf(&quot;第六行 - c 的值为 %d\n&quot;, a )</span><br><span class="line">   a--</span><br><span class="line">   fmt.Printf(&quot;第七行 - c 的值为 %d\n&quot;, a )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一行 - c 的值为 31</span><br><span class="line">第二行 - c 的值为 11</span><br><span class="line">第三行 - c 的值为 210</span><br><span class="line">第四行 - c 的值为 2</span><br><span class="line">第五行 - c 的值为 1</span><br><span class="line">第六行 - c 的值为 22</span><br><span class="line">第七行 - c 的值为 21</span><br></pre></td></tr></table></figure>
<h3 id="关系运算符"><a class="header-anchor" href="#关系运算符">¶</a> 关系运算符</h3>
<p>下表列出了所有Go语言的关系运算符。假定 A 值为 10，B 值为 20。</p>
<table>
<thead>
<tr>
<th>运算符号</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>==</td>
<td>检查两个值是否相等，如果相等返回 True 否则返回 False。</td>
<td>(A == B) 为 False</td>
</tr>
<tr>
<td>!=</td>
<td>检查两个值是否不相等，如果不相等返回 True 否则返回 False。</td>
<td>(A != B) 为 True</td>
</tr>
<tr>
<td>&gt;</td>
<td>检查左边值是否大于右边值，如果是返回 True 否则返回 False。</td>
<td>(A &gt; B) 为 False</td>
</tr>
<tr>
<td>&lt;</td>
<td>检查左边值是否小于右边值，如果是返回 True 否则返回 False。</td>
<td>(A &lt; B) 为 True</td>
</tr>
<tr>
<td>&gt;=</td>
<td>检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。</td>
<td>(A &gt;= B) 为 False</td>
</tr>
<tr>
<td>&lt;=</td>
<td>检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。</td>
<td>(A &lt;= B) 为 True</td>
</tr>
</tbody>
</table>
<p>以下实例演示了关系运算符的用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   var a int &#x3D; 21</span><br><span class="line">   var b int &#x3D; 10</span><br><span class="line"></span><br><span class="line">   if( a &#x3D;&#x3D; b ) &#123;</span><br><span class="line">      fmt.Printf(&quot;第一行 - a 等于 b\n&quot; )</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      fmt.Printf(&quot;第一行 - a 不等于 b\n&quot; )</span><br><span class="line">   &#125;</span><br><span class="line">   if ( a &lt; b ) &#123;</span><br><span class="line">      fmt.Printf(&quot;第二行 - a 小于 b\n&quot; )</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      fmt.Printf(&quot;第二行 - a 不小于 b\n&quot; )</span><br><span class="line">   &#125; </span><br><span class="line">   </span><br><span class="line">   if ( a &gt; b ) &#123;</span><br><span class="line">      fmt.Printf(&quot;第三行 - a 大于 b\n&quot; )</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      fmt.Printf(&quot;第三行 - a 不大于 b\n&quot; )</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;* Lets change value of a and b *&#x2F;</span><br><span class="line">   a &#x3D; 5</span><br><span class="line">   b &#x3D; 20</span><br><span class="line">   if ( a &lt;&#x3D; b ) &#123;</span><br><span class="line">      fmt.Printf(&quot;第四行 - a 小于等于  b\n&quot; )</span><br><span class="line">   &#125;</span><br><span class="line">   if ( b &gt;&#x3D; a ) &#123;</span><br><span class="line">      fmt.Printf(&quot;第五行 - b 大于等于 b\n&quot; )</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一行 - a 不等于 b</span><br><span class="line">第二行 - a 不小于 b</span><br><span class="line">第三行 - a 大于 b</span><br><span class="line">第四行 - a 小于等于  b</span><br><span class="line">第五行 - b 大于等于 b</span><br></pre></td></tr></table></figure>
<h3 id="逻辑运算符"><a class="header-anchor" href="#逻辑运算符">¶</a> 逻辑运算符</h3>
<p>下表列出了所有Go语言的逻辑运算符。假定 A 值为 True，B 值为 False。</p>
<table>
<thead>
<tr>
<th>运算符号</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;&amp;</td>
<td>逻辑 AND 运算符。 如果两边的操作数都是 True，则条件 True，否则为 False。</td>
<td>(A &amp;&amp; B) 为 False</td>
</tr>
<tr>
<td>||</td>
<td>逻辑 OR 运算符。 如果两边的操作数有一个 True，则条件 True，否则为 False。</td>
<td>(A</td>
</tr>
<tr>
<td>|</td>
<td>逻辑 NOT 运算符。 如果条件为 True，则逻辑 NOT 条件 False，否则为 True。</td>
<td>!(A &amp;&amp; B) 为 True</td>
</tr>
</tbody>
</table>
<p>以下实例演示了逻辑运算符的用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   var a bool &#x3D; true</span><br><span class="line">   var b bool &#x3D; false</span><br><span class="line">   if ( a &amp;&amp; b ) &#123;</span><br><span class="line">      fmt.Printf(&quot;第一行 - 条件为 true\n&quot; )</span><br><span class="line">   &#125;</span><br><span class="line">   if ( a || b ) &#123;</span><br><span class="line">      fmt.Printf(&quot;第二行 - 条件为 true\n&quot; )</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;* 修改 a 和 b 的值 *&#x2F;</span><br><span class="line">   a &#x3D; false</span><br><span class="line">   b &#x3D; true</span><br><span class="line">   if ( a &amp;&amp; b ) &#123;</span><br><span class="line">      fmt.Printf(&quot;第三行 - 条件为 true\n&quot; )</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      fmt.Printf(&quot;第三行 - 条件为 false\n&quot; )</span><br><span class="line">   &#125;</span><br><span class="line">   if ( !(a &amp;&amp; b) ) &#123;</span><br><span class="line">      fmt.Printf(&quot;第四行 - 条件为 true\n&quot; )</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上实例运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第二行 - 条件为 true</span><br><span class="line">第三行 - 条件为 false</span><br><span class="line">第四行 - 条件为 true</span><br></pre></td></tr></table></figure>
<h3 id="位运算符"><a class="header-anchor" href="#位运算符">¶</a> 位运算符</h3>
<p>位运算符对整数在内存中的二进制位进行操作。</p>
<p>下表列出了位运算符 &amp;, |, 和 ^ 的计算：</p>
<table>
<thead>
<tr>
<th>p</th>
<th>q</th>
<th>p &amp; q</th>
<th>p | q</th>
<th>p ^ q</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>假定 A = 60; B = 13; 其二进制数转换为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A &#x3D; 0011 1100</span><br><span class="line">B &#x3D; 0000 1101</span><br><span class="line"></span><br><span class="line">-----------------</span><br><span class="line">A&amp;B &#x3D; 0000 1100</span><br><span class="line">A|B &#x3D; 0011 1101</span><br><span class="line">A^B &#x3D; 0011 0001</span><br><span class="line">~A  &#x3D; 1100 0011</span><br></pre></td></tr></table></figure>
<p>C 语言支持的位运算符如下表所示。假定 A 为60，B 为13：</p>
<table>
<thead>
<tr>
<th>运算符号</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;</td>
<td>按位与运算符&quot;&amp;&quot;是双目运算符。 其功能是参与运算的两数各对应的二进位相与。</td>
<td>(A &amp; B) 结果为 12, 二进制为 0000 1100</td>
</tr>
<tr>
<td>|</td>
<td>按位或运算符&quot;|&quot;是双目运算符。 其功能是参与运算的两数各对应的二进位相或</td>
<td>(A | B) 结果为 61, 二进制为 0011 1101</td>
</tr>
<tr>
<td>^</td>
<td>按位异或运算符&quot;^&quot;是双目运算符。 其功能是参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。</td>
<td>(A ^ B) 结果为 49, 二进制为 0011 0001</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左移运算符&quot;&lt;&lt;&quot;是双目运算符。左移n位就是乘以2的n次方。</td>
<td>A &lt;&lt; 2 结果为 240 ，二进制为 1111 0000 其功能把&quot;&lt;&lt;“左边的运算数的各二进位全部左移若干位，由”&lt;&lt;&quot;右边的数指定移动的位数，高位丢弃，低位补0。</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移运算符&quot;&gt;&gt;“是双目运算符。右移n位就是除以2的n次方。 其功能是把”&gt;&gt;“左边的运算数的各二进位全部右移若干位，”&gt;&gt;&quot;右边的数指定移动的位数。</td>
<td>A &gt;&gt; 2 结果为 15 ，二进制为 0000 1111</td>
</tr>
</tbody>
</table>
<p>以下实例演示了逻辑运算符的用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">   var a uint &#x3D; 60	&#x2F;* 60 &#x3D; 0011 1100 *&#x2F;  </span><br><span class="line">   var b uint &#x3D; 13	&#x2F;* 13 &#x3D; 0000 1101 *&#x2F;</span><br><span class="line">   var c uint &#x3D; 0          </span><br><span class="line"></span><br><span class="line">   c &#x3D; a &amp; b       &#x2F;* 12 &#x3D; 0000 1100 *&#x2F; </span><br><span class="line">   fmt.Printf(&quot;第一行 - c 的值为 %d\n&quot;, c )</span><br><span class="line"></span><br><span class="line">   c &#x3D; a | b       &#x2F;* 61 &#x3D; 0011 1101 *&#x2F;</span><br><span class="line">   fmt.Printf(&quot;第二行 - c 的值为 %d\n&quot;, c )</span><br><span class="line"></span><br><span class="line">   c &#x3D; a ^ b       &#x2F;* 49 &#x3D; 0011 0001 *&#x2F;</span><br><span class="line">   fmt.Printf(&quot;第三行 - c 的值为 %d\n&quot;, c )</span><br><span class="line"></span><br><span class="line">   c &#x3D; a &lt;&lt; 2     &#x2F;* 240 &#x3D; 1111 0000 *&#x2F;</span><br><span class="line">   fmt.Printf(&quot;第四行 - c 的值为 %d\n&quot;, c )</span><br><span class="line"></span><br><span class="line">   c &#x3D; a &gt;&gt; 2     &#x2F;* 15 &#x3D; 0000 1111 *&#x2F;</span><br><span class="line">   fmt.Printf(&quot;第五行 - c 的值为 %d\n&quot;, c )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一行 - c 的值为 12</span><br><span class="line">第二行 - c 的值为 61</span><br><span class="line">第三行 - c 的值为 49</span><br><span class="line">第四行 - c 的值为 240</span><br><span class="line">第五行 - c 的值为 15</span><br></pre></td></tr></table></figure>
<h3 id="赋值运算符"><a class="header-anchor" href="#赋值运算符">¶</a> 赋值运算符</h3>
<p><a href="http://www.runoob.com/go/go-operators.html" target="_blank" rel="noopener">http://www.runoob.com/go/go-operators.html</a></p>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css">]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>而立之年</title>
    <url>/51281/</url>
    <content><![CDATA[<h1 id="那是我三十岁写的"><a class="header-anchor" href="#那是我三十岁写的">¶</a> 那是我三十岁写的</h1>
<p>而立之年，意味着什么？应该成家立业、应该事业有根基、应该负起责任、应该…有人说未来十年很难，咬咬牙就挺过去了。按说不应有那么多<code>应该</code>，人有不通的性格，不通的成长轨迹，不同的生活经历，怎能用同一<code>应该</code>而强为之。</p>
<p>以为，未来十年，不是一个爱做梦的年纪，而是一个梦醒了需要脚踏实地变为现实的年纪。有自己的想法、价值和抱负。</p>
<p>只有努力让自己成为更好的人</p>
<p>却不能强迫别人来爱自己</p>
<p>在人生的路上</p>
<p>每个人</p>
<p>都会跌跌撞撞</p>
<p>有几处伤疤</p>
<p>都会彷徨失措</p>
<p>要的是勇敢的站起来</p>
<p>爱以相濡以沫携手白头</p>
<p>时光的荏苒慢明白，多东西。</p>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css">]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>杂文</tag>
      </tags>
  </entry>
  <entry>
    <title>Sketch软件学习笔记</title>
    <url>/8684/</url>
    <content><![CDATA[<h2 id="基本介绍"><a class="header-anchor" href="#基本介绍">¶</a> 基本介绍</h2>
<h3 id="学习人群"><a class="header-anchor" href="#学习人群">¶</a> 学习人群</h3>
<ol>
<li>移动界面设计师、UI设计师</li>
<li>交互设计师</li>
<li>产品经理</li>
<li>移动端开发工程师 bingo!</li>
</ol>
<h3 id="开发公司"><a class="header-anchor" href="#开发公司">¶</a> 开发公司</h3>
<ul>
<li>国家：荷兰 海牙</li>
<li>出自：Bohemiancoding</li>
<li>官网：<a href="https://www.sketchapp.com" target="_blank" rel="noopener">https://www.sketchapp.com</a></li>
</ul>
<h3 id="下载和安装"><a class="header-anchor" href="#下载和安装">¶</a> 下载和安装</h3>
<p>官网下载</p>
<p><a href="https://pan.baidu.com/s/1gfAApof" target="_blank" rel="noopener">汉化包密码:<code>g8be</code></a><br>
汉化包下载后双击，安装，再打开Sketch软件后在工具栏的插件，点击<code>工具</code>-&gt;<code>sketch l18n</code>即可切换中英文版本。</p>
<h3 id="软件界面"><a class="header-anchor" href="#软件界面">¶</a> 软件界面</h3>
<p><img src="/images/pasted-4.png" alt="upload successful"></p>
<ul>
<li>工具栏(工具箱)<br>
可以进行拖拽图标，或者拖拽设定好的栏目，这个非常人性化。<br>
工具栏包括了skech的所有工具</li>
</ul>
<p><img src="/images/pasted-5.png" alt="upload successful"></p>
<h3 id="基本形状绘制"><a class="header-anchor" href="#基本形状绘制">¶</a> 基本形状绘制</h3>
<p><img src="/images/pasted-6.png" alt="upload successful"></p>
<p><em><strong>对应快捷键</strong></em>：矩形<code>r</code>,圆形<code>o</code>,圆角矩形<code>u</code>,线条<code>l</code>，<br>
如果需要的是正方形则<code>r</code>+<code>shift</code>，如果需要正圆形<code>o</code>+<code>shift</code>，如果需要正圆角矩形则<code>u</code>+<code>shift</code>,如果需要直线则<code>l</code>+<code>shift</code></p>
<p>如果希望所画的图形不是从右上角开始，而是从中心点开始扩散，则需要按<code>shift</code>+<code>option/alt</code>键即可。</p>
<h3 id="基本操作"><a class="header-anchor" href="#基本操作">¶</a> 基本操作</h3>
<p><em><strong>图层复制的方法</strong></em>：鼠标选中图形，按住<code>option/alt</code>键，拖动图形即可复制，如果需要图形复制过程中<code>强制水平</code>则需要同时按住<code>shift</code>键；<br><br>
<em><strong>取色吸管</strong></em>：选中对象按<code>ctrl</code>+<code>c</code>即可调出取色吸管。<br><br>
<em><strong>描边和填充快捷键</strong></em>：<code>b</code>取消描边，再按一下<code>b</code>有添加描边了，<code>f</code>取消填充，再按一下<code>f</code>又加上填充了。<br>
<em><strong>文字工具</strong></em>：<code>t</code>,输入文字即可。<br>
<em><strong>钢笔工具</strong></em>：<code>v</code>,输入文字即可。</p>
<h3 id="图形的属性"><a class="header-anchor" href="#图形的属性">¶</a> 图形的属性</h3>
<h4 id="常规属性"><a class="header-anchor" href="#常规属性">¶</a> 常规属性</h4>
<p><img src="/images/pasted-7.png" alt="upload successful"></p>
<h4 id="样式属性"><a class="header-anchor" href="#样式属性">¶</a> 样式属性</h4>
<h5 id="填充（f）和描边（b）"><a class="header-anchor" href="#填充（f）和描边（b）">¶</a> 填充（f）和描边（b）</h5>
<p>注意如果删除一个填充的时候，要点掉对应填充前面的✔️，再点击垃圾桶图标即删除了一个图层的填充。</p>
<p><img src="/images/pasted-8.png" alt="upload successful"></p>
<h4 id="阴影和内阴影"><a class="header-anchor" href="#阴影和内阴影">¶</a> 阴影和内阴影</h4>
<p>比较容易理解</p>
<h4 id="模糊类型"><a class="header-anchor" href="#模糊类型">¶</a> 模糊类型</h4>
<p><img src="/images/pasted-9.png" alt="upload successful"></p>
<ol>
<li>高斯模糊：常用，将选择的图形进行模糊化处理。</li>
<li>动感模糊：选择的图形进行动感模糊，可以调整角度。</li>
<li>放大模糊：姜选择图形以中心向四周模糊化处理。</li>
<li>背景模糊：可以制作苹果系统下的磨砂模糊效果（色块为白色，并且需要将填充不透明度调整为60%方可实现效果）</li>
</ol>
<h3 id="画板的创建和大小调整"><a class="header-anchor" href="#画板的创建和大小调整">¶</a> 画板的创建和大小调整</h3>
<p><em><strong>画板放大</strong></em>：按住<code>command</code>键，滚动鼠标滑轮，表示整体放大和缩小。<br><br>
<em><strong>画板局部元素放大</strong></em>：按住<code>z</code>键，点击鼠标左键，即可实现局部元素的放大。或者框选即可实现放大。<br><br>
<em><strong>移动画板</strong></em>：按住<code>空格</code>键，鼠标会变成抓手，即可移动画布。</p>
<h4 id="画板的创建"><a class="header-anchor" href="#画板的创建">¶</a> 画板的创建</h4>
<p>画板是在UI设计时最常用的页面设计工具，例如设计APP时候有很多个页面，在Sketch中一个文档可以创建无数个页面。<br><br>
在选择的页面中选择的元素，可以跨画板进行拖拽。</p>
<p><img src="/images/pasted-10.png" alt="upload successful"><br>
也可以是 按住<code>a</code>间，在画布上自定义画，或者按照右侧的规范选择。</p>
<h4 id="编组"><a class="header-anchor" href="#编组">¶</a> 编组</h4>
<p>编组把若干个元素组合成为一个组，和PPT，PS中的分组是一个意思。快捷键为<code>ctrl+g</code></p>
<h4 id="图形的编辑"><a class="header-anchor" href="#图形的编辑">¶</a> 图形的编辑</h4>
<p>双击或者点击编辑按钮，单击可以添加锚点。完成编辑按回车键就可以对当前图形完成 。</p>
<h3 id="布尔运算"><a class="header-anchor" href="#布尔运算">¶</a> 布尔运算</h3>
<p><img src="/images/pasted-11.png" alt="upload successful"></p>
<ol>
<li>合并形状：得到几个形状区域的和。</li>
<li>减去：去掉上层包括上层和下层形状中的重叠部分。</li>
<li>相交：得到两个形状重叠的部分。</li>
<li>排除：去掉两个形状重叠的部分。</li>
</ol>
<blockquote>
<p>注意：执行布尔运算后依然合一通过图层对其进行分开，我们可执行拼合命令使其转换为一个图形，在没有拼合之前可以在图层中选择图层展开后进行后续的修改，或者布尔类型的修改。一旦拼合后则不能进行修改。</p>
</blockquote>
<p><img src="/images/pasted-13.png" alt="upload successful"></p>
<p>模仿了几个图标进行布尔运算的应用：</p>
<blockquote>
<p>注意事项 还是需要多联系  主要是合并形状 和 减去的应用。</p>
</blockquote>
<h3 id="蒙版"><a class="header-anchor" href="#蒙版">¶</a> 蒙版</h3>
<p>有两种蒙版，一个是图形蒙版，一个是透明度蒙版。</p>
<h4 id="图形蒙版"><a class="header-anchor" href="#图形蒙版">¶</a> 图形蒙版</h4>
<p><img src="/images/pasted-12.png" alt="upload successful"></p>
<p><img src="/images/pasted-14.png" alt="upload successful"></p>
<ol>
<li>图片在上  图形在下</li>
<li>两个元素分组，选择图形，执行图形蒙版。</li>
<li>两个元素不分组，选择两个元素，执行图形蒙版。</li>
</ol>
<h4 id="透明度蒙版 alpha蒙版"><a class="header-anchor" href="#透明度蒙版 alpha蒙版">¶</a> 透明度蒙版 alpha蒙版</h4>
<p><img src="/images/pasted-15.png" alt="upload successful"></p>
<p>是将图形进行透明度蒙版的操作，倒影的效果。</p>
<ol>
<li>在图形下方创建一个矩形，矩形渐变色为黑色到黑色</li>
<li>下侧的黑色透明度改为0</li>
<li>复制图片，倒置镜像，拖动到矩形内</li>
<li>选择矩形和图片，点击蒙版，即上边的倒影效果。</li>
</ol>
<h4 id="缩放（元素自身的大小变化）"><a class="header-anchor" href="#缩放（元素自身的大小变化）">¶</a> 缩放（元素自身的大小变化）</h4>
<p><img src="/images/pasted-16.png" alt="upload successful"></p>
<h4 id="旋转复制（自定义工具栏中找到旋转复制按钮拖动到工具栏中）"><a class="header-anchor" href="#旋转复制（自定义工具栏中找到旋转复制按钮拖动到工具栏中）">¶</a> 旋转复制（自定义工具栏中找到旋转复制按钮拖动到工具栏中）</h4>
<p><img src="/images/pasted-17.png" alt="upload successful"></p>
<ol>
<li>画一个圆形点击旋转复制按钮，选择6，则效果如上。</li>
</ol>
<h4 id="剪刀 去除元素"><a class="header-anchor" href="#剪刀 去除元素">¶</a> 剪刀 去除元素</h4>
<p><img src="/images/pasted-18.png" alt="upload successful"><br>
比如上图</p>
<p>制作模仿的logo</p>
<p><img src="/images/pasted-19.png" alt="upload successful"></p>
<h4 id="钢笔、矢量工具"><a class="header-anchor" href="#钢笔、矢量工具">¶</a> 钢笔、矢量工具</h4>
<ol>
<li>直线 点击开始  按 下一个点  在按下一个点</li>
<li>按住<code>command</code>键拖动操作。</li>
</ol>
<h4 id="转换为轮廓"><a class="header-anchor" href="#转换为轮廓">¶</a> 转换为轮廓</h4>
<p>将钢笔(v)的路径属性转换为图形属性，也就是说转换好后可以为图形添加填充和描边的效果。</p>
<h4 id="文字工具(t)"><a class="header-anchor" href="#文字工具(t)">¶</a> 文字工具(t)</h4>
<p>快捷键是<code>t</code>,调整文字大小可以用<code>alt command</code>加<code>+</code>/<code>-</code>。</p>
<h4 id="创建网格"><a class="header-anchor" href="#创建网格">¶</a> 创建网格</h4>
<p>可以创建所选中的图形，按照行和列的方式进行复制，并可设定间距。<br>
<img src="/images/pasted-20.png" alt="upload successful"></p>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css">]]></content>
      <categories>
        <category>前端设计</category>
      </categories>
      <tags>
        <tag>Sketch</tag>
      </tags>
  </entry>
  <entry>
    <title>java代码格式化模板（阿里代码规范）</title>
    <url>/2918/</url>
    <content><![CDATA[<h3 id="文件准备"><a class="header-anchor" href="#文件准备">¶</a> 文件准备</h3>
<p>网盘文件：链接：<a href="https://pan.baidu.com/s/1f56Ywufl8CdBHyc4b4fBQQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1f56Ywufl8CdBHyc4b4fBQQ</a><br>
提取码：zneo</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>p3c-formatter</td>
<td>模板文件</td>
</tr>
<tr>
<td>EclipseFormatter.zip</td>
<td>idea插件</td>
</tr>
<tr>
<td>阿里巴巴Java开发手册（详尽版）.pdf</td>
<td>代码规范手册</td>
</tr>
</tbody>
</table>
<p>官方文件：</p>
<p>格式化模板文件下载地址：<a href="https://github.com/alibaba/p3c/tree/master/p3c-formatter" target="_blank" rel="noopener">https://github.com/alibaba/p3c/tree/master/p3c-formatter</a></p>
<table>
<thead>
<tr>
<th>文件</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>eclipse-codestyle.xml</td>
<td>代码格式化时用的模板</td>
</tr>
<tr>
<td>eclipse-codetemplate.xml</td>
<td>注释模板</td>
</tr>
</tbody>
</table>
<p><img src="/images/pasted-21.png" alt="upload successful"></p>
<h3 id="eclipse 格式化设置"><a class="header-anchor" href="#eclipse 格式化设置">¶</a> eclipse 格式化设置</h3>
<h4 id="1. 格式化模板导入"><a class="header-anchor" href="#1. 格式化模板导入">¶</a> 1. 格式化模板导入</h4>
<ul>
<li>依次点击：Window-&gt;Preferences-&gt;Java-&gt;Code Style-&gt;Formatter-&gt;Import</li>
<li>选择eclipse-codestyle.xml文件确定</li>
<li>默认在Active profile中选择新导入的P3C-CodeStyle，如未选择，请手动选择</li>
<li>点击Apply完成配置</li>
</ul>
<p><img src="/images/pasted-22.png" alt="upload successful"></p>
<h4 id="2. 注释模板导入"><a class="header-anchor" href="#2. 注释模板导入">¶</a> 2. 注释模板导入</h4>
<ul>
<li>操作流程同上，Window-&gt;Preferences-&gt;Java-&gt;Code Style-&gt;Code Templates-&gt;Import</li>
<li>勾选Automatically add comments for new methods and types</li>
<li>点击Apply完成配置</li>
</ul>
<p><img src="/images/pasted-23.png" alt="upload successful"></p>
<h4 id="3.properties文件编码UTF-8"><a class="header-anchor" href="#3.properties文件编码UTF-8">¶</a> 3.properties文件编码UTF-8</h4>
<ul>
<li>Window-&gt;Preferences-&gt;General-&gt;Content Types-&gt;Text-&gt;Java Properties File</li>
<li>将Java Properties File及下属的所有项均设定为 Default encoding: UTF-8</li>
</ul>
<p><img src="/images/pasted-24.png" alt="upload successful"></p>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css">]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>eclipseformatter</tag>
      </tags>
  </entry>
  <entry>
    <title>电商后台设计</title>
    <url>/63397/</url>
    <content><![CDATA[<h3 id="本文包括以下几个部分："><a class="header-anchor" href="#本文包括以下几个部分：">¶</a> 本文包括以下几个部分：</h3>
<ul>
<li>电商后台系统概述</li>
<li>电商后台产品设计：商品中心</li>
<li>电商后台产品设计：订单拆单</li>
<li>电商后台产品设计：促销活动解析</li>
<li>电商后台产品设计：优惠券的设计和妙用</li>
</ul>
<h4 id="1.电商后台系统到底是怎么回事儿"><a class="header-anchor" href="#1.电商后台系统到底是怎么回事儿">¶</a> 1.电商后台系统到底是怎么回事儿</h4>
<p>每年的“双十二”“双十一”人造购物节一来，电商群战就好不热闹，马云却预言纯电商时代已去，新零售时代已至。作为一名电商产品经理，身处如此时代，亦会觉得不负青春。</p>
<p>做产品以来，主要做后端支撑产品方向，目前对各模块系统都有所涉及。初次接触时，在网上找了很多资料，发现关于产品的相关文章，大部分都是关于产品体验、交互、APP等，提及后台的文章基本浅尝辄止，很少有文章来系统介绍后台各模块（商品、订单、营销、物流、支付、会员、评价、采购…）,就计划写一系列关于后台各模块的产品设计文章，希望能够帮助在产品路上成长的PM。</p>
<p>后台系统，也不能叫做一个系统，很多公司将其拆分为很多子系统，阿里更将其发展成了中台事业群（搜索事业部、共享业务平台、数据技术）。后端一系列系统支撑着公司各种业务的进行和发展，前端展示、业务处理（订单、优惠券）、库存变动等进行时，后端各系统间互相调用接口进行数据更新。</p>
<p>由于商业性质决定了电商业务支撑系统必须具备稳定性、可扩展、安全性强等特点，PM在设计产品架构时，应充分考虑到业务发展需要，尽量将各模块隔离，商品模块建个商品中心，订单模块建个订单中心等等。只有在产品设计上有模块化思想，具有前瞻性，技术在开发时才会考虑业务隔离，当业务调整、功能新增时，开发可迅速进行，避免牵一发而动全身的事情反复发生。</p>
<p>针对一般电商业务，我简单画了一张产品模块示意图，基本一些中小型电商公司的产品架构大致如此。除了图中所示，现在很多电商公司开始转型社交电商，采用UGC模式或直播电商，在产品架构上会新增资讯系统，实现资讯与商品的高度融合，本文不过多涉及。</p>
<p>对电商公司来讲，最核心最难做的三部分：商品、订单、库存。</p>
<p>商品与店铺、营销、评价等相关，订单与会员、营销、支付、库存、物流等相关，库存与订单、采购、WMS、营销等相关，系统之间业务逻辑和交互异常复杂，规则多样。</p>
<p><img src="/images/pasted-25.png" alt="upload successful"></p>
<ul>
<li>商品中心：主要管理SKU(最小库存单位)、SPU（标准化产品单元）、属性（关键属性、非关键属性、销售属性）、类目品牌、价格等有关商品的数据；</li>
<li>订单中心：管理订单类型、订单状态，落下关于商品、优惠、用户、收货信息、支付信息等一系列的订单实时数据，进行库存更新、订单下发等一系列动作；</li>
<li>支付中心主要调用第三方支付平台接口，记录支付信息（对应订单号、支付金额等）；</li>
<li>会员中心：主要管理用户等级、用户权益、积分、卡券等会员相关信息；调度中心主要将订单信息转化为发货通知单，调度仓库和物流进行发货；</li>
<li>客服中心：主要管理退货退款、售后服务等操作，包括呼叫中心、在线客服等，与之对应的是工单系统，将客服任务进行队列管理，分配给相应的客服；</li>
<li>营销中心：主要管理活动相关，优惠券、满减、专场活动、促销专区等，营销工具的开发对电商尤其重要，营销活动的滥用造成的用户疲劳，怎样推陈出新，给电商产品经理造成了很大挑战；</li>
<li>运营中心：主要是对用户端进行页面配置（Banner、ICON、TAB）、价格管理等，一般会营销中心并入运营，作为其一部分；</li>
<li>评价中心：管理商品评价和用户反馈，这并没有想象的那么简单，涉及到一些敏感词和敏感图片的筛选，以及回复内容管理；</li>
<li>店铺管理：功能庞杂，相当于提供给B端用户一个Saas管理后台，提供管理商品、营销、订单一系列功能，主要针对一些有to B业务的电商开放平台；</li>
<li>采购中心：管理SKU，当库存预警时，及时生成采购单进行入库，有供应商管理模块，主要进行供应商管理评级，发展新供应商等功能；</li>
<li>财务管理：主要和订单、采购系统相关，数据准确性要求较高；</li>
<li>WMS系统（仓库管理系统）：主要是入库、出库、盘点等模块，WMS主要和调度中心进行数据交互，反馈出入库状态和库存变动；</li>
<li>物流中心：主要进行运费模板、运费管理（前端订单、真实物流成本）、物流状态保存查询（快递100、菜鸟等关联），如果是跨境电商，还涉及到和海关总署的对接，进行报关操作。</li>
<li>风控中心：主要利用大数据进行用户信用建设、反欺诈，避免恶意评价、刷单退款等操作，构建安全的电商购物环境。</li>
</ul>
<p>对电商后端支撑线各模块的业务功能有初步认知之后，可以看到的是，平常手机中的一个电商APP，背后是若干系统在支撑着，亦是许多技术和产品人员在辛苦付出。</p>
<p>以客户下订单为例来介绍业务信息在各系统之间的流转，涉及主要的信息交互如下图所示。从用户选择商品、生成订单到订单出库、物流配送、用户签收、退货退款，信息在多系统中流转更新数据。</p>
<p><img src="/images/pasted-26.png" alt="upload successful"></p>
<p>从图中可以看出前台的一小步，后台的一大步。对于产品经理来讲，理清各系统之间的业务逻辑，特别是在商品类型多样（服务商品、实物商品、服务加实物商品等），业务复杂（预售、代销、代发等）时，各系统模块的隔离，设计时考虑扩展性非常必要。</p>
<h4 id="2.如何设计实用的商品中心"><a class="header-anchor" href="#2.如何设计实用的商品中心">¶</a> 2.如何设计实用的商品中心</h4>
<p>（前端显示篇）</p>
<p>每天逛淘宝和京东的时候，映入眼帘的都是品类繁多的商品，但是当我们选择分类或者直接搜索的时候，按条件筛选时，系统却往往能从千万商品中提供心中想要的商品；在浏览商品时，商品主图、详情图、规格等信息让我们感觉比在超市拿着实物获得更多信息，电商系统到底是怎么做到这些的呢？</p>
<p>简单粗暴地讲，商品中心是用来管理核心的商品数据。对于使用的维度：从前端来讲，是给商品展示、订单、营销活动提供商品数据支撑，从后端来讲，商品中心给订单发货、仓库管理、供应商管理、采购提供基础数据支撑。</p>
<p>为了更清晰地描述商品中心这项重量级工程，文章分为两部分从上述两个维度来阐述，第一部分主要从后端的维度介绍商品中心。第二部分主要从商品前端显示来说后台设计的那些事儿。</p>
<h5 id="一、 商品常用概念介绍"><a class="header-anchor" href="#一、 商品常用概念介绍">¶</a> 一、 商品常用概念介绍</h5>
<p>先介绍几个基本概念：SKU、SPU、属性、类目。</p>
<ul>
<li>SKU</li>
</ul>
<p>stock keeping uint（库存量单位），库存控制的最小可用单位。例如Iphone 7plus 128G 银色就是一个SKU，仓库管理、采购进货、库存显示的都是SKU。</p>
<p>不同的公司都有自己的SKU编码规则，如果有自己的仓库，在商品入库时一般会打上自己的SKU码，这样整一套库存体系就会自上而下打通，当然还有另一种处理方式，设置自有SKU码与供应商条码的对应关系，将订单转化为发货单时，将自有SKU码转化为供应商的条码。</p>
<p>对大公司来说，推荐前一种做法，后一种由于供应商编码规则不同，或者管理规范，在实际操作往往会增加出错率。</p>
<p><img src="/images/pasted-27.png" alt="upload successful"></p>
<ul>
<li>SPU</li>
</ul>
<p>standard product unit（标准化产品单元），是一组标准化信息的集合，例如Iphone 7plus就是一个SPU。SPU与SKU的关系有许多种，可以一对多，一对一，如下图所示。</p>
<p>SPU信息中应该包含SPU属性、产品图片、产品描述、产品标签。SPU和SKU之间是通过规格来链接的。SPU(Iphone 7plus)通过颜色、内容关联到SKU(Iphone 7plus 128G 银色)。SPU的库存是由其对应的SKU库存共同决定的。</p>
<p><img src="/images/pasted-28.png" alt="upload successful"></p>
<ul>
<li>属性</li>
</ul>
<p>分为关键属性、销售属性、非关键属性。关键属性是指能够唯一确定产品的属性，是必填项。例如手机的品牌、型号属于关键属性；销售属性组成SKU的特殊属性，或称为规格属性，如手机的”颜色”、”内存”；非关键属性指的是除关键属性、销售属性外的其他属性，如手机的手机接口类型，非关键属性不一定是非必填项，有时为了商品信息完整，也会设为必填项。属性定义对于良好的消费体验有着至关重要的关系，对搜索、索引、筛选都有至关重要的作用。</p>
<ul>
<li>类目</li>
</ul>
<p>分类树，电商常用的有两层类目，前台展示类目，后端商品类目。前台类目指的是展示给消费者的类目，会根据季节、销售策略、活动进行变动；后台类目属于基础数据，不可随意变动，添加SKU时都需要选择类目，进行绑定。</p>
<p>需要注意的是，类目树的层次不能太深，一般三层或四层，如果太深，不论对于管理还是技术性能来说，都是不利的。前台类目与后台类目可随意搭配，设置前台类目关联时，对前台类目树最深层进行设置，可让其关联后台类目任一层，可一对一、一对多。前台类目还可以对应品牌。</p>
<p><img src="/images/pasted-29.png" alt="upload successful"></p>
<h5 id="二、商品基础资料设计"><a class="header-anchor" href="#二、商品基础资料设计">¶</a> 二、商品基础资料设计</h5>
<p>在介绍商品常用概念时，也透露了很多在产品设计时关联的信息。在添加SKU时，需要选择品牌、填写一些属性，以及关于仓库管理的基础数据（长宽高、重量、供应商等）。</p>
<p>商品中心基础资料结构图主要如下，首先是品类管理，主要包括品牌管理(中英文名、可供品类、产地（跨境电商比较重要）)、属性管理（针对类目添加相关属性和属性值）、类目管理（后端类目树重中之重，确定时要考虑全面，属于基础数据，后续更改比较麻烦。），大致产品框架如图所示。</p>
<p><img src="/images/pasted-30.png" alt="upload successful"></p>
<p>在添加SKU时，通过供应商去关联采购，进而影响仓库中SKU的库存。供应商在添加SKU时亦可不选择，可以在采购系统中添加关联。通过销售属性去关联SPU与SKU，同一SPU在前台显示时可以共用同一商品详情，只是通过规格属性映射到具体的SKU；针对商品的关键属性和属性值，可以在商品搜索和筛选时用上，良好的属性定义对于顾客决策树的缩短有着至关重要的作用。</p>
<p><img src="/images/pasted-31.png" alt="upload successful"></p>
<h5 id="三、复盘"><a class="header-anchor" href="#三、复盘">¶</a> 三、复盘</h5>
<p>商品中心后端属于基础数据，会被许多子系统调用，对于电商公司来说重中之重。商品中心提供接口数据进行仓库管理、采购管理、库存管理、订单管理，可扩展的商品中心结构将给公司业务发展带来很大益处。</p>
<p>文后扩展，很多电商公司业务定位都是B2B2C，为了扩充SKU，增加用户量，或者构建平台体系，都会允许第三方来平台管理商品，类似京东、有赞，这类平台的商品结构更加复杂，SKU需要增加所属商家，商品详情、属性值、库存都需要相互独立，在SKU、SPU纬度上增加一个商家纬度。这里不做过多扩展，感兴趣的朋友可以深入思考。</p>
<h4 id="如何设计实用的商品中心"><a class="header-anchor" href="#如何设计实用的商品中心">¶</a> 如何设计实用的商品中心</h4>
<p>（后台设计篇）</p>
<p>用户平常购物接触到最多的就是商品显示页，商品列表、商品详情页的基础信息都是从商品中心获取。目前对于商品设计有着成熟的产品方案，电商网站的商品产品结构大同小异，淘宝上的商品以SPU形态显示，京东上以SKU形态显示，两种处理方式各有优劣势（表达可能不太准确，但认真研究过两者商品结构应该理解我说的不同点，下文解释）。 其实我更倾向于淘宝的商品结构，能够支持更加灵活的商品方案。</p>
<p><img src="/images/pasted-32.png" alt="upload successful"></p>
<p>京东与淘宝的商品详情页</p>
<p>商品信息主要由类目、标题、品牌、商品属性、规格（京东定义为销售属性）、价格、库存、SKU信息（毛重、长宽高等）、商品图、商品详情描述、物流信息等组成。至于经常看到的服务标签（白条、极速退款）、商品标签（热销）、活动标签（满减、优惠券）、价格标签（拼团价、活动价）、同类商品等都是在商品信息上的包装层，不在本文的阐述范围。</p>
<h4 id="一、商品类目、商品基本信息"><a class="header-anchor" href="#一、商品类目、商品基本信息">¶</a> 一、商品类目、商品基本信息</h4>
<p>商品类目分为两层，基础数据类目层、前台展示类目层，在添加和管理商品时，都是在基础数据类目层对商品进行管理（如下图）。商品属性、销售属性及品牌等很多数据都是在基础类目上进行管理，所以类目管理属于较为核心的工作，一定要从长远角度考虑。</p>
<p>在添加商品时，需选择对应的类目。前台类目在展示时，有两种处理方式：</p>
<ul>
<li>前台类目对应后台类目，可一对一、一对多、多对多，自由组合，动态调整。现在大部分自营电商都是用的这种类型。</li>
<li>前台类目直接对应商品，适合商品较少的小商家，主要是一些电商平台提供给平台上商家的类目服务，添加商品时直接选择前台展示的类目。<br>
另外，类目一般是分为三层，类目树不要太深，否则将影响产品效率。</li>
</ul>
<p><img src="/images/pasted-33.png" alt="upload successful"></p>
<p>JD商品类目</p>
<p>设置商品信息、副标题（一般介绍产品卖点、促销），选择商品对应的品牌。在品牌管理中，有两种方案：1.品牌统一管理，小公司商品丰富度较少时的方案。2.品牌关联类目，商品丰富度高的选择。</p>
<p><img src="/images/pasted-34.png" alt="upload successful"></p>
<p>基本信息编辑</p>
<p>商品属性包括属性名、属性值，一般都是挂在具体类目子叶下，设置必填和非必填。在设置属性值时，须保留一定的扩展性，部分允许自定义属性。商品属性管理要求强大的类目运营能力，在中小型电商平台一般会提供基础属性值，再开放自定义属性编辑，让用户来完善属性库数据。</p>
<p>商品搜索能力，除了标题、类目，很大部分依赖于商品属性，条件筛选的基础数据也是商品属性和规格属性。完善商品属性对于良好用户体验至关重要。</p>
<p><img src="/images/pasted-35.png" alt="upload successful"></p>
<p>淘宝的商品属性（男装&gt;风衣）</p>
<h5 id="三、规格、价格、库存、SKU信息"><a class="header-anchor" href="#三、规格、价格、库存、SKU信息">¶</a> 三、规格、价格、库存、SKU信息</h5>
<p>在购买商品时，我们会经常选择规格（销售属性），主要包括颜色、尺寸，为了支持多样化的用户需求，选择之后可以编辑规格。规格一对一确定之后，可单独设置价格、库存、商家SKU，淘宝上亦可添加条形码（69码）。也可以设置统一价、统一库存。填写商家SKU主要是为了方便对应到具体的实物，上文亦讲过，仓库和采购管理的都是具体的SKU。</p>
<p>仔细观察会发现，京东的商品标题是加上具体的规格，在选择规格时会跳转SKU，对于落单数据有效率提升，但是对于页面效率和体验是不如淘宝的SPU结构的。现在大部分电商都采用的是淘宝的SPU结构，亦是优质选择。</p>
<p><img src="/images/pasted-36.png" alt="upload successful"></p>
<p>JD规格、价格、库存、SKU设置页面</p>
<p>在淘宝上选择具体的规格后，会发现商品缩略图会发生变化，这就需要在管理商品时，针对某规格单独上传图片。这里有个设计很巧妙的地方，只是不同颜色需要上传对应的商品缩略图，而尺码不需要。</p>
<p><img src="/images/pasted-37.png" alt="upload successful"></p>
<p>针对商品设置平台价和市场价，主要是为了商品在列表展示商品、未选择具体规格时展示，相当于商品的均价。毛重、长宽高等数据主要是为了物流而设置的，自建仓库的自营电商一般在SKU数据层就会录入这些数据，直接调用。货号即商品编码，在商城购物时会扫描的条形码就是货号。货号不等同于SKU编码，同一商品编码的商品可能是不同SKU，有着不同的规格，所以不能直接拿货号来管理SKU。</p>
<p><img src="/images/pasted-38.png" alt="upload successful"></p>
<h4 id="四、商品图、商品详情描述、物流信息"><a class="header-anchor" href="#四、商品图、商品详情描述、物流信息">¶</a> 四、商品图、商品详情描述、物流信息</h4>
<p>除了不同规格对应的商品缩略图，商品图还包括商品主图，一般要求图片质量较高，包括整体图和细节图。商品主图是吸引顾客眼球的必要利器，不论是列表页，还是活动页，顾客除了关注价格，主要就是商品主图，运营上架时需对商品主图较为慎重。</p>
<p>商品详情页现在一般会区分电脑版和手机版，由于两者的使用场景和设备不同，侧重点也不相同。为了更好的展示产品特点，可提供不同的产品详情模板，亦可支持不同的富文本编辑。</p>
<p><img src="/images/pasted-39.png" alt="upload successful"></p>
<p>选择运费服务时，要选择对应的物流模板（包邮、按重量、按件数等），在订单处理是按照具体的物流模板计算运费。运费模板计算较为多样复杂，下篇文章详细描述讲解物流运费相关的细节。</p>
<p><img src="/images/pasted-40.png" alt="upload successful"></p>
<h5 id="五、其他商品信息"><a class="header-anchor" href="#五、其他商品信息">¶</a> 五、其他商品信息</h5>
<p>主要包括售后服务（发票、保修服务、退换货）、包装清单等相关说明。</p>
<h5 id="六、上下架管理"><a class="header-anchor" href="#六、上下架管理">¶</a> 六、上下架管理</h5>
<p>设置完商品基本信息之后，设置上下架时间，亦可直接上架发布。和商品相关的活动，一旦商品下架，活动将失效，无法购买。搜索、筛选的商品范围都是在上架的商品范围进行。</p>
<p><img src="/images/pasted-41.png" alt="upload successful"></p>
<p>在商品管理层面，平台电商提供给平台商户的商品服务与自营电商自己的商品服务有着很大不同。最大区别在于自营电商比平台电商多SKU管理，库存和属性都是基于SKU进行管理，在添加商品时，如果还要重新填写，就会造成数据冗余。所以一般会共用数据。</p>
<h4 id="4.电商后台产品设计：优惠券的设计和妙用"><a class="header-anchor" href="#4.电商后台产品设计：优惠券的设计和妙用">¶</a> 4.电商后台产品设计：优惠券的设计和妙用</h4>
<p>优惠券是一种常见的促销方式，在规定的周期内购买对应商品类型和额度的商品时，结算时满足一定条件会减免一定金额。通过发放优惠券，引导用户购买相应的商品，在下单的时候抵扣一定的费用，达到促销、提高客单价的目标。</p>
<p>优惠券不论在线上还是线下，适用范围都比较广泛。例如滴滴发的专车券、外卖平台发的外卖券、京东淘宝的优惠券等。</p>
<h5 id="一、优惠券的类型和应用场景"><a class="header-anchor" href="#一、优惠券的类型和应用场景">¶</a> 一、优惠券的类型和应用场景</h5>
<p>优惠券有多种分类方式，按照使用门槛、使用范围、发放主体等有不同的分类。</p>
<ul>
<li>1.1 按照使用门槛分为现金券、满减券、折扣券。</li>
</ul>
<p>现金券：不限制订单金额，可以直接使用。</p>
<p>满减券：订单金额需要满足一定的最低额度才可使用，例如：满100减10元优惠券。</p>
<ul>
<li>1.2 按照适用范围分为：单品券、品类券、品牌券。</li>
</ul>
<p>单品券：购买优惠券指定商品时可使用，这种优惠券一般只针对少量特殊商品可以使用。</p>
<p>品类券：购买优惠券指定类别的商品即可使用，除个别特殊商品。</p>
<p>品牌券：购买优惠券指定品牌的商品时可使用，除个别特殊商品。</p>
<p>一般按照品牌或者品类设置优惠券范围是比较常见的方式。</p>
<ul>
<li>1.3 按照发放的主体分为平台优惠券和店铺优惠券</li>
</ul>
<p>平台优惠券：优惠由平台承担，比如平台活动优惠券、平台注册的新人优惠券、平台积分兑换的优惠券。</p>
<p>店铺优惠券：在平台上的店铺自己发放的优惠券，比如淘宝上的店铺优惠券、京东的店铺优惠券。</p>
<p>平台优惠券的金额由平台承担，在店铺使用时优惠金额由平台返给店铺；店铺优惠券的成本由店铺自己承担。</p>
<h5 id="二、优惠券的设计规则"><a class="header-anchor" href="#二、优惠券的设计规则">¶</a> 二、优惠券的设计规则</h5>
<p>从优惠券的生命周期，来设计优惠券是最恰当的。</p>
<p><img src="/images/pasted-42.png" alt="upload successful"></p>
<ul>
<li>2.1 生成优惠券</li>
</ul>
<p>在生成优惠券时，主要是从优惠券信息和推广信息两方面来考虑优惠券的设计。</p>
<ul>
<li>
<p>2.1.1 优惠券信息</p>
</li>
<li>
<p>优惠券名称</p>
</li>
<li>
<p>类型：现金券、满减券、折扣券</p>
</li>
<li>
<p>面值：例如10元。</p>
</li>
<li>
<p>使用条件：满XX元可用</p>
</li>
<li>
<p>使用平台：客户端、H5商城、主站、各分销渠道</p>
</li>
<li>
<p>有效期时间：绝对时间（时间段）、相对时间（领取之日后多少天有效）</p>
</li>
<li>
<p>发行量：优惠券张数（设置限额）</p>
</li>
<li>
<p>使用范围：平台券（全平台通用）、店铺券（仅在某店铺可用）</p>
</li>
<li>
<p>商品范围：全品类、限制品类、限制商品</p>
</li>
<li>
<p>2.1.2   推广信息</p>
</li>
<li>
<p>发放方式：可发放可领取、仅可发放(只能由平台发放给用户)、仅可领取（只能用户自己领取或兑换）</p>
</li>
<li>
<p>推广范围：免费领取、积分兑换</p>
</li>
<li>
<p>优惠券是否公开：设置公开后，在领券专区、商品详情页、购物车都默认展示</p>
</li>
<li>
<p>限领：每人仅限一张、每人每天限领一张</p>
</li>
<li>
<p>券领取时间：设置领取时间段（过期）<br>
在优惠券生成之后，将优惠券显示在优惠券列表中。</p>
</li>
<li>
<p>2.2 发送优惠券</p>
</li>
</ul>
<p>优惠券有主动领取和被动领取两种方式。</p>
<ul>
<li>主动领取：</li>
</ul>
<p>用户在店铺首页或者平台上看到优惠券，主动进行领取；用户在线下看到宣传推广；朋友圈优惠券分享链接等等。</p>
<p>这种发放方式需要一定的运营成本，需要打动用户，产生兴趣进行主动领取，这种方式需要做好防作弊机制，真正获取到的用户价值较高。</p>
<ul>
<li>被动领取：</li>
</ul>
<p>系统主动给用户发送相应的优惠券，但是这种大面积分发的方式，用户精准度低，转化率较低，只能很少促进客单量。</p>
<p>系统发放优惠券场景有很多种：1.用户注册；2.大促活动；3.还有客服发券，主要是售后补偿（平台责任导致售后，发券补偿客户），或者好评返现。</p>
<p>除了以上的方式，还有许多平台电商的一项业务：大客户团购，主要是给一些单位提供的福利卡，例如京东卡。可以通过优惠券（平台币）的形式实现，生成相应的卡密（或兑换码），制作实物卡售卖给一些公司发福利、送礼。用户输入卡密兑换之后，兑换成平台的交易币（相当于给购物卡充值），可以用来抵扣订单金额。</p>
<p>发送优惠券虽然在前端页面只是简单的一个交互，但是后端有大量的逻辑需要处理。</p>
<p>校验用户登录状态 → 优惠券信息读取（是否在有效期、是否可发放、剩余数量） → 优惠券绑定用户</p>
<ul>
<li>2.3 优惠券核销</li>
</ul>
<p>在用户下单时，肯定是需要系统从其账户中的优惠券选择合适的优惠券推荐给其使用的。我思考的推荐算法应该分三步：</p>
<p>从用户优惠券列表中选择出当前订单可用的优惠券（包括通用券和相应产品优惠券），主要是从有效期、商品范围等条件判断<br>
若有多种可用优惠券，但是金额不同，默认选择可抵扣最高的优惠券。<br>
如果金额相同，先匹配同类优惠券的优惠券，但当优惠券的额度（现金券）大于支付额度弹出提醒框，确认是否使用。<br>
注：在用户的优惠券列表中，优惠券是否失效也是实时拉取的（失效过长应清除此优惠券），下单时优惠券选择应仅显示用户可用优惠券。</p>
<ul>
<li>2.4 优惠券统计</li>
</ul>
<p>主要统计优惠券的发送张数、使用张数。深度数据挖掘可以统计优惠券对应的客单价、复购率等等。</p>
<h5 id="三、优惠券的前端展示"><a class="header-anchor" href="#三、优惠券的前端展示">¶</a> 三、优惠券的前端展示</h5>
<p>优惠券的前端露出窗口主要有五处：用户优惠券列表、订单提交页、购物车、商品详情页、领券中心（或优惠券分享链接）。</p>
<p>前端展示的难点在于商品详情页和购物车中展示可用优惠券。需要高效率的算法来计算匹配商品对应的优惠券，主要有两点好处：1.优惠券来促进用户消费；2.在用户消费时帮助用户省钱。告知用户有优惠可以享受，避免用户下单之后看到相关优惠没有享受到产生不平衡心理。</p>
<p><img src="/images/pasted-43.png" alt="upload successful"></p>
<h5 id="四、优惠券在订单中的处理"><a class="header-anchor" href="#四、优惠券在订单中的处理">¶</a> 四、优惠券在订单中的处理</h5>
<p>下单时优惠券的匹配在前面已经叙述过，主要是分为三步，详见2.3优惠券的核销。本节重点讲解优惠券的逆向流程。</p>
<p>在订单完成售后（退款或退货）时，优惠券应有一定的返还机制。</p>
<p>统一设置成不可返还，用了之后就不退。<br>
订单中全部退款时，优惠券全部退还。<br>
订单中部分退款时，普通优惠券不返还，现金券按金额比例退还。<br>
优惠券有着一套很成熟的产品设计方案，介绍之后，再提一个目前绝大部门产品难以解决的问题：基于日常优惠券的使用情况，运营人员如何平衡发放优惠券所带来的成本增长，商品销量增长和单品毛利下降之间的矛盾？在申请促销活动经费时，怎样的数据更具说服力？</p>
<h4 id="5.电商后台产品设计：促销活动解析"><a class="header-anchor" href="#5.电商后台产品设计：促销活动解析">¶</a> 5.电商后台产品设计：促销活动解析</h4>
<p>促销是最常见的电商运营手段，每到重要节日，类似双十一、618、情人节等等，商家在线上或是线下都会展开疯狂的促销大战，通过各样的形式吸引消费者。作为电商的从业者，应该对各种促销手段有所了解。这部分内容将从产品设计的角度来介绍各种促销手段。</p>
<h5 id="一、促销综述"><a class="header-anchor" href="#一、促销综述">¶</a> 一、促销综述</h5>
<p>促销就是营销者向消费者传递有关产品的各种信息，吸引或促进消费者购买其产品，以达到扩大销售量的目的。促销对提高客单量、客单价、复购率甚至注册量都有一定的好处。很多电商平台或店铺在起步阶段会通过大量的促销活动来吸引消费者，获取流量。</p>
<p>促销有利有弊，对平台来说不一定是好事，频繁的促销容易给顾客产生疲劳，透支未来收入，甚至会降低品牌定位。</p>
<h5 id="二、促销的各种类型"><a class="header-anchor" href="#二、促销的各种类型">¶</a> 二、促销的各种类型</h5>
<p>促销有多种形式，目前电商系统能够支持的促销形式我大致总结了一下，大约有7种：满减促销、单品促销、套装促销、赠品促销、满赠促销、多买优惠促销、定金促销。</p>
<p>这7种促销形式几乎囊括了各电商平台所有的促销方案，特别提一下“定金促销&quot;的形式在2016年双十一开始广泛应用，对电商供应链的备货和物流控制大有益处。</p>
<ul>
<li>满减促销： 购物者只要购买相应商品到规定价格即可得到一定的减价优惠。主要有两种形式：阶梯满减、每满减。阶梯满减，例：满100减10、满300减50、满500减80；每满减，例：设置每满200减20，则订单金额230元实付210元，订单金额430元实付390元。</li>
<li>单品促销：在特定时间内购买指定商品享受一定的价格优惠。例：促销期间商品6折，原价100元，购买时60元。</li>
<li>套装促销：商品组合套装以优惠价出售，例如：A商品50元，B商品80元，A+B商品套装促销价100元。</li>
<li>赠品促销：购买主商品之后赠送商品（可多个）。</li>
<li>满赠促销：有满XX元送XX商品、满满XX元加价XX元送XX商品，与赠品促销的区别在于以相应商品订单的价格来区分，可分阶设置，例如满300元送自拍杆，满500送充电宝，满1000送高端耳机等。</li>
<li>多买优惠促销：有M元任选N件、M件N折两种优惠形式。这个主要是参考一些线下卖场发展的促销形式。</li>
<li>定金促销：在商品正式售卖之前采用预付定金的促销模式，提前交定金可享受优惠价。定金预售有多种玩法：定金预购，相当于定金就已经确认订单；定金杠杆，例如定金10元可抵扣30元。</li>
</ul>
<h5 id="三、促销的后台设计"><a class="header-anchor" href="#三、促销的后台设计">¶</a> 三、促销的后台设计</h5>
<p>刚刚介绍到的几种促销方式在设计上都大同小异，主要分为活动条件、主商品信息、赠品信息（有些无赠品）这三部分。</p>
<ul>
<li>3.1 活动条件</li>
</ul>
<p>主要包括促销活动名称、促销时间、限购数量、促销范围（全网、APP /微信商城）、会员级别（全员  or 新注册用户 or 某等级会员）、活动备注、活动规则。</p>
<p>活动规则即最核心的设置，例如：满800元减60，3件150元。</p>
<p><img src="/images/pasted-44.png" alt="upload successful"></p>
<p>满减规则设置（来自京东）</p>
<ul>
<li>3.2 主商品信息</li>
</ul>
<p>选择参加活动的商品，可按SPU、分类、品牌等来选择参加促销的商品。</p>
<p>除此之外，还要判断当前所选商品是否参与其他促销活动，与此活动由冲突。例如A商品参加4月的活动，满400元减20元；再次设置该商品参加满400减50的活动，就应与该商品已参加活动冲突，不可设置。</p>
<p><img src="/images/pasted-45.png" alt="upload successful"></p>
<ul>
<li>3.3 赠品信息</li>
</ul>
<p>选择参加活动的赠品，赠品一般有数量限制。有两种规则，赠品全送，或在多赠品中选择几件。为减少系统复杂度，减少用户理解难度，建议采用赠品全送的规则。</p>
<p>另外对于满赠促销的形式，若要设置分级赠品（满300元送自拍杆，满500送充电宝，满1000送高端耳机），就需要对赠品分开进行设置。</p>
<p><img src="/images/pasted-46.png" alt="upload successful"></p>
<p>对于后台产品来讲，重点在于设置规则之后在商品详情页、购物车的促销信息展示以及订单页面的促销活动判断逻辑。</p>
<h5 id="四、前端展示"><a class="header-anchor" href="#四、前端展示">¶</a> 四、前端展示</h5>
<p>在商品详情页，要去判断商品对应的所有促销活动，例如加价购、满赠、赠品等促销活动。</p>
<p><img src="/images/pasted-47.png" alt="upload successful"></p>
<p>在购物车，除了展示促销信息（满赠、满减、套装、换购）的作用，还可以让用户在多优惠并存只能选其一的情况下，可以选择修改促销方案。（感觉京东已经把购物车的功能做到极致了）</p>
<p><img src="/images/pasted-48.png" alt="upload successful"></p>
<p>在订单详情页，判断当前所选商品的促销信息（促销价、赠品、换购商品等），将所有相关商品记入订单信息中，再算出促销价格。</p>
<p><img src="/images/pasted-49.png" alt="upload successful"></p>
<p>企业利用各种促销的方法和手段，使消费者了解和注意企业的产品、激发消费者的购买欲望，并促使其最终购买。每年源源不断的促销已经造成消费者对促销麻木，只有在促销与正常销售之间寻找合适的平衡点，才是企业的生存之道。</p>
<h4 id="6.电商后台产品设计：订单拆单"><a class="header-anchor" href="#6.电商后台产品设计：订单拆单">¶</a> 6.电商后台产品设计：订单拆单</h4>
<p>最近在做拆单的需求，细思极恐，思考越深入，就会发现里面涉及的东西越来越多，要想做好订单拆单的功能，还是相当有难度，因此总结了一下拆单功能细节，分享出来。</p>
<p>拆单也有两个层次，第一次是在提交订单后支付之前拆单，这次是拆分的订单，一次是在下单之后，发货之前，去拆分发货单（SKU层面）。</p>
<p>两次拆单的原则不同，第一次拆单是为了区分平台商家、方便财务结算，第二次拆单是为了按照最后的发货包裹进行拆单，如不同仓库、不同运输要求的SKU、包裹重量体积限制等因素（第二次拆单的有些步骤可以放在第一步）。</p>
<p>需要注意的是，若是跨境商品平台，则需要在支付前完成所有拆单步骤，因为报关需要三单对碰，订单、支付单、运单统一。</p>
<h5 id="一、 为什么要拆单"><a class="header-anchor" href="#一、 为什么要拆单">¶</a> 一、 为什么要拆单</h5>
<p>拆单，顾名思义就是客户在下单之后，为了发货和结算方便，需要对订单进行拆分。</p>
<p>影响拆单的因素主要有以下几点：</p>
<ul>
<li>店铺商家。由于商品归属权不同，涉及到财务结算和发货的问题，店铺商家不同，需要拆分订单。例如京东自营和平台商家的商品在下单时会拆分成不同的子订单，售后入口不同。或者不同淘宝店同时下单会按照店铺进行拆单。</li>
<li>仓库。由于发货仓库不同，按照商品归属的仓库进行拆单，若有多仓有货，还应按照地域时效选择仓库进行拆单。</li>
<li>品类。由于商品属性和价值得不同，同样会产生拆单需求。例如易碎品需要特殊包装，超大物品（儿童座椅、轮胎）需要单独包装。甚至有些品类不同的商品不能放在一起，都需要来定义拆单规则。</li>
<li>物流因素。不同物流公司对单个包裹的重量或体积都有特殊要求，需要根据sku的毛重和体积计算包裹总重量和体积，超出物流公司限制的也需要拆单。</li>
<li>商品价值。这块的拆单主要是跨境海淘商品，国家政策规定：跨境电子商务零售进口商品的单次交易限值为人民币2000元，个人年度交易限值为人民币2万元。当单次购买超过2000元（单仓）之后，就需要对订单拆单。（总不能告诉用户少买点，不要超过两千吧！）</li>
</ul>
<h5 id="二、拆单流程"><a class="header-anchor" href="#二、拆单流程">¶</a> 二、拆单流程</h5>
<p>根据拆单的一些影响因素，需要对订单进行拆分。由于跨境电商和国内电商的区别点：</p>
<p>跨境电商一般是单品单仓，同一个SKU只在一个仓库有，而国内电商一般有多个区域仓，从时效最高的仓库发货；<br>
跨境电商需要报关，必须三单统一，所以拆单只能发生在下单后、支付前，而国内电商除了平台商家不同需要在下单时就拆单，其他的拆单步骤可在下单之后再拆发货单；<br>
报关限额，只有跨境电商需要考虑。<br>
下图简单解析一下拆单的流程：</p>
<p><img src="/images/pasted-50.png" alt="upload successful"></p>
<p>拆单流程</p>
<h5 id="三、拆单之后的前端显示"><a class="header-anchor" href="#三、拆单之后的前端显示">¶</a> 三、拆单之后的前端显示</h5>
<p>在提交订单之后、支付之前的拆单订单，需要即时显示给用户，若用户中断支付，再回到支付环节，就需要分开支付。用户就能知道，是不同的包裹发过来的，分属不同的子订单。</p>
<p><img src="/images/pasted-51.png" alt="upload successful"></p>
<p>订单拆分（淘宝）</p>
<p>在支付之后，系统根据一些影响因素进行拆单，同一个子订单可能会对应多个物流单，在订单显示页面查看物流时，需要展示多个物流信息。但是现在多个平台只能一个订单对应一个物流单。有些订单无法通过一个包裹就能发货，在信息反馈给客户上就会有些瑕疵。</p>
<p>关于支付单，虽然基本所有平台都会通过合并支付的方式简化支付环节，但是不同的子订单都是可以拿到不同的支付单号的，这样就有利于售后和财务管理，对于跨境商品，还有报关的作用。</p>
<h4 id="小结"><a class="header-anchor" href="#小结">¶</a> 小结</h4>
<p>拆单的系统比较复杂，要做的完全彻底，对大部分电商公司有很大的困难，这需要打通从订单系统到WMS系统的许多环节，所以需要在产品设计上进行取舍，根据平台的具体需求来确定拆单需求的优先级。</p>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css">]]></content>
      <categories>
        <category>CC211</category>
      </categories>
      <tags>
        <tag>电商业务</tag>
      </tags>
  </entry>
</search>
